include("FunctionsProjections")


# ================================================
# ADMM SOCP con vincoli conici, Ax = g e Ax ≤ c
# ================================================
function admm_socp(x0, Soc:: SOC, obj, H; 
                   F=nothing, g=nothing,    # vincoli lineari di uguaglianza
                   A=nothing, c=nothing, Clamp,    # vincoli lineari di disuguaglianza
                   ρ=1.0, max_iter=200, tol=1e-6)

    n = length(x0)
    m = length(Soc.Ind_Soc)
    mv = length(Soc.Ind_t_Soc)
    # ms = length(Soc.t_Soc)
    nu = length(Clamp)

    # Variabili primali
    x = copy(x0)
    z = m > 0 ? zeros(n, m) : zeros(0,0)
    u = m > 0 ? zeros(n, m) : zeros(0,0)

    # Variabili per disuguaglianze
    if A !== nothing && length(A)
        zA = zeros(n)
        uA = zeros(n)
    end

    if nu > 0
        zU = zeros(nu)
        uU = zeros(nu)
    end


    # ============================
    # Costruzione della matrice Hx per l'x-update
    # ============================
    Hx = copy(H)  # H è la matrice quadratica dell'obiettivo

    # 1️⃣ Contributo dei vincoli conici
    if m > 0
        for i in 1:m
            idx_vec = Soc.Ind_Soc[i]
            # aggiungi rho su tutte le variabili coinvolte nel vincolo
            Hx[idx_vec, idx_vec] +=  ρ * Matrix{Float64}(I, length(idx_vec), length(idx_vec))
        end

        if mv > 0
            for i in 1:mv
                idx_scal = Soc.Ind_t_Soc[i]
                # aggiungi rho su tutte le variabili coinvolte nel vincolo
                Hx[idx_scal, idx_scal] += ρ
            end
        end
    else
        sum_z_u = zeros(n)
    end

    # 2️⃣ Contributo dei vincoli lineari di disuguaglianza Ax <= c
    if A !== nothing && length(A) > 0
        for i in 1:n
            Hx[i,i] += ρ   # aggiungi ρ solo alle variabili coinvolte in A
        end
    end

    # 3️⃣ Contributo dei vincoli di clamp su u
    if nu > 0
        for i in Clamp
            Hx[i,i] += ρ   # aggiungi ρ solo alle variabili di controllo u
        end
    end


    Hx = Hx  # Hx quadraticausing SparseArrays

    if F === nothing && size(F,1) == 0
        Hx_fact = factorize(Hx)
    else
        KKT = [Hx F'; F zeros(size(F,1), size(F,1))]
        KKT_fact = lu(KKT)
    end


    for k in 1:max_iter
        # =========================================
        # x-update completo per costo quadratico
        # =========================================


        # Contributo dei vincoli di disuguaglianza lineari
        extra_term = zeros(n)
       if A !== nothing && length(A) > 0
            @views extra_term .+= zA - uA
        end

        if nu > 0
            @views extra_term[n-nu+1:end] .+= zU - uU
        end

        if m > 0 
            sum_z_u = zeros(n)
            for j in 1:m
                @views sum_z_u .+= z[:,j] .- u[:,j]
            end
        end


        # Vettore right-hand side
        f = ρ*sum_z_u + ρ*extra_term - obj

        if F !== nothing && size(F,1) != 0
            # Vincoli lineari di uguaglianza F x = g
            # Risolvo sistema KKT:
            # [Hx  F'; F 0] [x; λ] = [f; g]
            rhs = vcat(f, g)
            sol = KKT_fact \ rhs
            x = sol[1:n]      # estraggo x
        else
            # Nessun vincolo lineare di uguaglianza
            x = Hx_fact \ f
        end

        if any(isnan, x)
            error("NaN rilevato")
        end

        # --- z-update (coni) ---
        if m>0
            for i in 1:m
                idx_vec = Soc.Ind_Soc[i]
                if i <= mv
                    idx_scal = Soc.Ind_t_Soc[i]
                    z[idx_vec,i], z[idx_scal,i] = proj_soc(x[idx_vec] + u[idx_vec,i], x[idx_scal] + u[idx_scal,i] )
                else
                    idx_scal = i - mv 
                    # display(x[idx_vec] + u[idx_vec,i])
                    z[idx_vec,i] = proj_soc(x[idx_vec] + u[idx_vec,i], Soc.t_Soc[idx_scal])
                    # z[idx_vec,i] = clamp.(x[idx_vec] + u[idx_vec,i], - Soc.t_Soc[idx_scal], Soc.t_Soc[idx_scal])

                end
            end
        end

        # --- z-update (disuguaglianze Ax ≤ c) ---
        if A !== nothing && length(A)
            zA = proj_polytope!(x + uA, A, c)
        end

        # z-update per controllo con vincolo u_min <= u <= u_max

        
        if nu > 0
            @views xU = x[Clamp] # estraggo u_k da x
            zU .= clamp.(xU .+ uU, -0.2, 0.2)
        end


        # --- u-update ---
        if m>0
            for i in 1:m
                idx_vec = Soc.Ind_Soc[i]
                u[idx_vec,i] += x[idx_vec] - z[idx_vec,i]
            end
        end
        if A !== nothing && length(A)
            uA += x - zA
        end

        if nu > 0
            uU += xU - zU
        end

        # --- Controllo convergenza ---
        r_norm = 0.0
        if m>0
            r_norm += sum(norm.(eachcol(x .- z)))
        end

        if A !== nothing
            r_norm += norm(x - zA)
        end

        if nu > 0
            r_norm += norm(x[n-nu+1:end] - zU)
        end

        if r_norm < tol
            println("Converged at iteration $k")
            break
        end
    end


    # ================================
    # Check generale fattibilità
    # ================================
    feasible = true


    # Vincoli conici
    for i in 1:length.Soc.Ind_Soc
        if i < mv
            dist = norm(x[Soc.ind_Soc[i]]) - x[Soc.Ind_t_Soc[i]]
            if abs(dist) >  tol
                println("⚠️ Violato vincolo conico: distanza = $dist")
                feasible = false
            end
        else
            dist = norm(x[Soc.ind_Soc[i]]) - Soc.t_Soc[i]
            if abs(dist) > tol
                println("⚠️ Violato vincolo conico: distanza = $dist")
                feasible = false
            end
        end
    end

    # Vincoli lineari di uguaglianza
    if F !== nothing && size(F,1) != 0
        residual = norm(F * x - g)
        if residual > tol
            println("⚠️ Violati vincoli lineari di uguaglianza: residuo = $residual")
            feasible = false
        end
    end

    # Vincoli di disuguaglianza
    if A !== nothing
        viol = A * x - c
        if any(viol .> tol)
            println("⚠️ Violati vincoli di disuguaglianza: max violazione = $(maximum(viol))")
            feasible = false
        end
    end

    return x, z
end