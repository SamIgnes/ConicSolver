include("FunctionsProjections")

# ==============================================================
# ADMM per SOCP (Second Order Cone Programming) con vincoli:
#   - Conici
#   - Lineari di uguaglianza (Fx = g)
#   - Lineari di disuguaglianza (Ax ≤ c)
#   - Clamp (limiti su subset di variabili di controllo)
#
# Parametri:
#   x0      : vettore iniziale
#   Soc     : struttura contenente indici e parametri dei coni
#   obj     : vettore gradiente del costo (termine lineare nell'obiettivo)
#   H       : matrice Hessiana dell'obiettivo quadratico
#
#   F, g    : vincoli lineari di uguaglianza (Fx = g)
#   A, c    : vincoli lineari di disuguaglianza (Ax ≤ c)
#   Box_ind   : indici delle variabili soggette a vincoli di clamp
#
# Opzioni:
#   ρ       : parametro di penalità ADMM
#   max_iter: numero massimo di iterazioni
#   tol     : tolleranza per la convergenza
#
# Output:
#   x       : soluzione primale
#   z       : variabili ausiliarie per vincoli conici
# ==============================================================

function admm_socp(x0, Soc::SOC, Rsoc::RSOC, obj, H,
                   F, g,       # vincoli lineari di uguaglianza
                   Ineq::INEQ; # vincoli lineari di disuguaglianza
                   ρ=1.0, max_iter=200, ε_abs = 1e-4, ε_rel = 1e-4, tol=1e-6)

    Box_ind, A, c, Ind_NonNeg = Ineq.Ind_Box, Ineq.A, Ineq.rhs_c, Ineq.Ind_NonNeg

    # ------------------------
    # Dimensioni del problema
    # ------------------------
    n  = length(x0)             # dimensione delle variabili
    m  = length(Soc.Ind_Soc)    # numero di vincoli conici
    mv = length(Soc.Ind_t_Soc)  # numero di vincoli conici con variabile t
    r  = length(Rsoc.Ind_x)
    ru = length(Rsoc.Ind_u)
    rv = length(Rsoc.Ind_v)
    nu = length(Box_ind)          # numero di variabili con clamp
    na = length(c)


    if na > 0
        # Aggiungi i vincoli di ineguaglianza generali alla matrice A
        A = hcat(A,zeros(na, na))
        for i in 1:na
            A[i, n + i] = 1.0  # variabile slack
            Ind_NonNeg = vcat(Ind_NonNeg, n + i)  # aggiungi variabile slack ai non-negativi
        end

        F = hcat(F, zeros(size(F, 1), size(A, 2) - size(F, 2)))
        F = vcat(F, A)
        g = vcat(g, c)
        # Espandi il vettore dei costi c per le nuove variabili slack
        obj = vcat(obj, zeros(na))
        H_new = zeros(n+na,n+na)
        H_new[1:n,1:n] = H 
        H = H_new 
        x0  = vcat(x0, zeros(na))
    end

    nn = length(Ind_NonNeg)
    na_copy = na
    na = 0

    # ------------------------
    # Variabili primali/dual
    # ------------------------
    x = copy(x0)

    # variabili primali
    x = copy(x0)
    # SOC
    z = m>0 ? zeros(n, m) : zeros(0,0)
    u = m>0 ? zeros(n, m) : zeros(0,0)

    # RSOC
    zR = r>0 ? zeros(n, r) : zeros(0,0)
    uR = r>0 ? zeros(n, r) : zeros(0,0)

    # disuguaglianze
    zA = na>0 ? zeros(n) : zeros(0)
    uA = na>0 ? zeros(n) : zeros(0)

    # clamp
    zU = nu>0 ? zeros(nu) : zeros(0)
    uU = nu>0 ? zeros(nu) : zeros(0)

    zN = nn>0 ? zeros(nn) : zeros(0)
    uN = nn>0 ? zeros(nn) : zeros(0)

    z_prev = copy(z)
    zR_prev = copy(zR)
    zU_prev = copy(zU)
    zN_prev = copy(zN)
    zA_prev = copy(zA)

    # ------------------------
    # Costruzione matrice Hx per l'update di x
    # ------------------------
    Hx = copy(H) 

    # 1️⃣ Contributo vincoli conici
    # SOC
    if m > 0
        for i in 1:m
            idx_vec = Soc.Ind_Soc[i]
            Hx[idx_vec, idx_vec] += ρ * I(length(idx_vec))
        end
        if mv > 0
            for i in 1:mv
                idx_scal = Soc.Ind_t_Soc[i]
                Hx[idx_scal, idx_scal] += ρ
            end
        end
    else
        sum_z_u = zeros(n)
    end

    # RSOC
    if r > 0
        for i in 1:r
            idx_vec = Rsoc.Ind_x[i]
            Hx[idx_vec, idx_vec] += ρ*I(length(idx_vec))
        end
        if ru > 0
            for i in 1:ru
                idx_u   = Rsoc.Ind_u[i]
                Hx[idx_u, idx_u] += ρ
            end
        end
        if rv > 0
            for i in 1:rv
                idx_v   = Rsoc.Ind_v[i]
                Hx[idx_v, idx_v] += ρ
            end
        end
    end

    # 2️⃣ Contributo vincoli di disuguaglianza Ax ≤ c
    if  na > 0
        for i in 1:n
            Hx[i,i] += ρ
        end
    end
 
    # 3️⃣ Contributo vincoli clamp
    if nu > 0
        for i in Box_ind
            Hx[i,i] += ρ
        end
    end

    if nn > 0
        for i in Ind_NonNeg
            Hx[i,i] += ρ
        end
    end

 
    # ------------------------
    # Fattorizzazioni (con o senza vincoli di uguaglianza)
    # ------------------------
    if F === nothing && size(F,1) == 0
        Hx_fact = factorize(Hx)
    else
        # KKT = [Hx F'; F zeros(size(F,1), size(F,1))]
        KKT = [sparse(Hx) F'; F spzeros(size(F,1), size(F,1))]
        KKT_fact = lu(KKT)
    end

    # ==========================================================
    # Iterazioni ADMM
    # ==========================================================
    for k in 1:max_iter

        # ------------------------
        # x-update
        # ------------------------
        extra_term = zeros(n + na_copy)

        # vincoli di disuguaglianza
        if na > 0
            @views extra_term .+= zA - uA
        end

        # clamp
        if nu > 0
            @views extra_term[Box_ind] .+= zU - uU
        end

        # non negatività
        if nn > 0
            @views extra_term[Ind_NonNeg] .+= zN - uN   
        end

        # Coni
        if m > 0
            sum_z_u = zeros(n)
            for j in 1:m
                @views sum_z_u .+= z[:,j] .- u[:,j]
            end
        end

        if r>0
            if m<1
                sum_z_u = zeros(n)
            end

            for j in 1:r
                sum_z_u .+= zR[:,j] - uR[:,j]
            end
        end

        # RHS per il sistema lineare
        f = ρ*vcat(sum_z_u,zeros(na_copy)) + ρ*extra_term - obj

        if  size(F,1) != 0
            # Risoluzione sistema KKT (con vincoli Fx = g)
            rhs = vcat(f, g)
            sol = KKT_fact \ rhs
            x = sol[1:n+na_copy]
        else
            # Caso senza vincoli di uguaglianza
            x = Hx_fact \ f
        end

        if any(isnan, x)
            error("NaN rilevato in x-update")
        end

        # ------------------------
        # z-update (vincoli conici)
        # ------------------------
        if m > 0
            for i in 1:m
                idx_vec = Soc.Ind_Soc[i]
                if i <= mv
                    idx_scal = Soc.Ind_t_Soc[i]
                    z[idx_vec,i], z[idx_scal,i] = proj_soc(x[idx_vec] + u[idx_vec,i], x[idx_scal] + u[idx_scal,i], false)
                else
                    idx_scal = i - mv
                    
                    z[idx_vec,i], _ = proj_soc(x[idx_vec] + u[idx_vec,i], Soc.t_Soc[idx_scal], true)
                end
            end
        end

        # ---------------- z-update RSOC
        if r>0
            for i in 1:r
                if  i <= ru && i <rv
                    idx_vec = Rsoc.Ind_x[i]
                    idx_u   = Rsoc.Ind_u[i]
                    idx_v   = Rsoc.Ind_v[i]
                    zR[idx_u,i] , zR[idx_v,i], zR[idx_vec,i] = proj_rsoc( x[idx_u] + uR[idx_u,i], x[idx_v] + uR[idx_v,i] , x[idx_vec] + uR[idx_vec,i] - Rsoc.Shift_x[i] , false, false)
                elseif i <= rv
                    idx_vec = Rsoc.Ind_x[i]
                    idx_v   = Rsoc.Ind_v[i]
                    _ , zR[idx_v,i], zR[idx_vec,i] = proj_rsoc( Rsoc.Value_u[i], x[idx_v] + uR[idx_v,i] , x[idx_vec] + uR[idx_vec,i] - Rsoc.Shift_x[i] , true, false)
                else
                    idx_vec = Rsoc.Ind_x[i]
                    _ , _, zR[idx_vec,i] = proj_rsoc(Rsoc.Value_u[i], Rsoc.Value_v[i] , x[idx_vec]+uR[idx_vec,i] - Rsoc.Shift_x[i] , true, true)
                end

             end
        end


        # ------------------------
        # z-update (vincoli Ax ≤ c)
        # ------------------------
        if  na > 0
            zA = proj_polytope(x + uA, A, c)
        end

        # ------------------------
        # z-update (Clamp: u_min ≤ u ≤ u_max)
        # ------------------------
        if nu > 0
            @views xU = x[Box_ind]
            zU .= clamp.(xU .+ uU, Ineq.rhs_BoxMin, Ineq.rhs_BoxMax)
        end

        if nn > 0
            @views xN = x[Ind_NonNeg]
            zN .= max.(0, xN + uN)
        end

        # ------------------------
        # u-update
        # ------------------------
        if m > 0
            for i in 1:mv
                idx_vec = Soc.Ind_Soc[i]
                idx_scal = Soc.Ind_t_Soc[i]
                u[idx_vec,i] += x[idx_vec] - z[idx_vec,i]
                u[idx_scal,i]+= x[idx_scal] - z[idx_scal,i]
            end
            for i in mv+1:m
                idx_vec = Soc.Ind_Soc[i]
                u[idx_vec,i] += x[idx_vec] - z[idx_vec,i]
            end
        end

        if r>0
            for i in 1:r
                if  i <= ru && i <rv
                    idx_vec = Rsoc.Ind_x[i]
                    idx_u   = Rsoc.Ind_u[i]
                    idx_v   = Rsoc.Ind_v[i]
                    uR[idx_vec,i] += x[idx_vec] - zR[idx_vec,i]
                    uR[idx_u,i]   += x[idx_u]   - zR[idx_u,i]
                    uR[idx_v,i]   += x[idx_v]   - zR[idx_v,i]
                elseif i<=rv
                    idx_vec = Rsoc.Ind_x[i]
                    idx_v   = Rsoc.Ind_v[i]
                    uR[idx_vec,i] += x[idx_vec] - zR[idx_vec,i]
                    uR[idx_v,i]   += x[idx_v]   - zR[idx_v,i]
                else
                    idx_vec = Rsoc.Ind_x[i]
                    uR[idx_vec,i] += x[idx_vec] - zR[idx_vec,i]
                end
            end
        end



        if  na > 0
            uA += x - zA
        end
        if nu > 0
            uU += xU - zU
        end
        if nn > 0
            uN += xN - zN
        end

        # ------------------------
        # Controllo convergenza
        # ------------------------
        r_norm = 0.0

        # SOC
        if m > 0
            for i in 1:m
                idx_vec = Soc.Ind_Soc[i]
                r_norm += sum(norm.(x[idx_vec] - z[idx_vec,i]))
            end

            for i in 1:mv
                idx_vec = Soc.Ind_Soc[i]
                idx_scal = Soc.Ind_t_Soc[i]
                r_norm += sum(norm.(x[idx_vec] - z[idx_vec,i]))
                r_norm += sum(norm.(x[idx_scal] - z[idx_scal,i]))
            end
            for i in mv+1:m
                idx_vec = Soc.Ind_Soc[i]
                r_norm += sum(norm.(x[idx_vec] - z[idx_vec,i]))
            end
        end
        
        # RSOC
        if r > 0
            for i in 1:r
                idx_vec = Rsoc.Ind_x[i]
                # idx_y = Soc.Ind_u[i]
                # idx_z = Soc.Ind_v[i]
                r_norm += sum(norm.(x[idx_vec] - zR[idx_vec,i]))
                # r_norm += sum(norm.(x[idx_y] - zR[idx_y,i]))
                # r_norm += sum(norm.(x[idx_z] - zR[idx_z,i]))
            end
        end
        # Ax ≤ c
        if na > 0
            r_norm += norm(x - zA)
        end
        # Clamp
        if nu > 0
            r_norm += norm(xU-zU)
        end
        #NonNeg
        if nn > 0
            r_norm += norm(xN-zN)
        end

        # Costruzione vettore z concatenato per tolleranza primale
        z_all = Float64[]
        if m > 0
            z_all = vcat(z_all, vec(z))
        end
        if r > 0
            z_all = vcat(z_all, vec(zR))
        end
        if na > 0
            z_all = vcat(z_all, zA)
        end
        if nu > 0
            z_all = vcat(z_all, zU)
        end
        if nn > 0
            z_all = vcat(z_all, zN)
        end
        rnorm = norm(z_all)

        # Tolleranza primale
        ε_pri = sqrt(n)*ε_abs + ε_rel*max(norm(x), norm(z_all))

        # ================================
        # Calcolo residui duali
        # ================================
        s_norm = 0.0
        if m > 0
            s_norm += norm(ρ * vec(z - z_prev))
        end
        if r > 0
            s_norm += norm(ρ * vec(zR - zR_prev))
        end
        if na > 0
            s_norm += norm(ρ * (zA - zA_prev))
        end
        if nu > 0
            s_norm += norm(ρ * (zU - zU_prev))
        end
        if nn > 0
            s_norm += norm(ρ * (zN - zN_prev))
        end

        # Tolleranza duale
        ε_dual = sqrt(n)*ε_abs + ε_rel*norm(ρ*u)

        # ================================
        # Check stop
        # ================================
        if r_norm <= ε_pri && s_norm <= ε_dual
            println("✅ Converged at iteration $k (r_norm=$r_norm, s_norm=$s_norm)")
            break
        end

        # Aggiorna z_prev per il prossimo passo
        z_prev  .= z
        zR_prev .= zR
        zA_prev .= zA
        zU_prev .= zU
        zN_prev .= zN

        # Messaggio se raggiunto max_iter
        if k == max_iter
            println("⚠️ Raggiunto il numero massimo di iterazioni ($max_iter) senza convergenza. r_norm=$r_norm, s_norm=$s_norm")
        end
    end

    # ==========================================================
    # Check generale di fattibilità
    # ==========================================================
    feasible = true

    # Vincoli conici
    for i in 1:length(Soc.Ind_Soc)
        if i <= mv
            dist = norm(x[Soc.Ind_Soc[i]]) - x[Soc.Ind_t_Soc[i]]
            if dist > tol
                println("⚠️ Violato vincolo conico: distanza = $dist")
                feasible = false
            end
        else
            dist = norm(x[Soc.Ind_Soc[i]]) - Soc.t_Soc[i]
            if dist > tol
                println("⚠️ Violato vincolo conico: distanza = $dist")
                feasible = false
            end
        end
    end
    #RSOC check
    for i in 1:r
            if  i <= ru && i <rv
                dist = norm(x[Rsoc.Ind_x[i]])^2 - 2*x[Rsoc.Ind_u[i]] * x[Rsoc.Ind_v[i]]
            elseif i <= rv
                dist = norm(x[Rsoc.Ind_x[i]])^2 - 2*Rsoc.Value_u[i]*x[Rsoc.Ind_v[i]]
            else
                dist = norm(x[Rsoc.Ind_x[i]])^2 - 2*Rsoc.Value_u[i]*Rsoc.Value_v[i]
            end

            if dist > tol
                println("⚠️ Violato vincolo conico: distanza = $dist")
                feasible = false
            end
    end

    # Vincoli lineari di uguaglianza
    if  size(F,1) != 0
        residual = norm(F * x - g)
        if residual > tol
            println("⚠️ Violati vincoli lineari di uguaglianza: residuo = $residual")
            feasible = false
        end
    end

    # Vincoli di disuguaglianza
    if na > 0
        viol = A * x - c
        if any(viol .> tol)
            println("⚠️ Violati vincoli di disuguaglianza: max violazione = $(maximum(viol))")
            feasible = false
        end
    end

    if nu > 0
        viol = vcat(abs.(x[Box_ind] - Ineq.rhs_BoxMax), abs.(x[Box_ind] - Ineq.rhs_BoxMin))
        if any(viol .> tol)
            println("⚠️ Violati vincoli di Bound: max violazione = $(maximum(viol))")
            feasible = false
        end
    end

    if nu > 0
        viol = x[Ind_NonNeg]
        if any(viol .<= -tol)
            println("⚠️ Violati vincoli di Non negatività: max violazione = $(minimum(viol))")
            feasible = false
        end
    end

    return x, z
end
