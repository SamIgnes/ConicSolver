include("FunctionsProjections")

# ==============================================================
# ADMM per SOCP (Second Order Cone Programming) con vincoli:
#   - Conici
#   - Lineari di uguaglianza (Fx = g)
#   - Lineari di disuguaglianza (Ax ≤ c)
#   - Clamp (limiti su subset di variabili di controllo)
#
# Parametri:
#   x0      : vettore iniziale
#   Soc     : struttura contenente indici e parametri dei coni
#   obj     : vettore gradiente del costo (termine lineare nell'obiettivo)
#   H       : matrice Hessiana dell'obiettivo quadratico
#
#   F, g    : vincoli lineari di uguaglianza (Fx = g)
#   A, c    : vincoli lineari di disuguaglianza (Ax ≤ c)
#   Box_ind   : indici delle variabili soggette a vincoli di clamp
#
# Opzioni:
#   ρ       : parametro di penalità ADMM
#   max_iter: numero massimo di iterazioni
#   tol     : tolleranza per la convergenza
#
# Output:
#   x       : soluzione primale
#   z       : variabili ausiliarie per vincoli conici
# ==============================================================

function admm_socp(x0, Soc::SOC, Rsoc::RSOC, obj, H,
                   F, g,       # vincoli lineari di uguaglianza
                   Ineq::INEQ; # vincoli lineari di disuguaglianza
                   ρ=1.0, max_iter=200, ε_abs = 1e-4, ε_rel = 1e-4, tol=1e-6)

    Box_ind, A, c = Ineq.Ind_Box, Ineq.A, Ineq.rhs_c

    # ------------------------
    # Dimensioni del problema
    # ------------------------
    n  = length(x0)             # dimensione delle variabili
    m  = length(Soc.Ind_Soc)    # numero di vincoli conici
    mv = length(Soc.Ind_t_Soc)  # numero di vincoli conici con variabile t
    r  = length(Rsoc.Ind_x)
    nu = length(Box_ind)          # numero di variabili con clamp
    na = length(c)

    # ------------------------
    # Variabili primali/dual
    # ------------------------
    x = copy(x0)

    # variabili primali
    x = copy(x0)
    # SOC
    z = m>0 ? zeros(n, m) : zeros(0,0)
    u = m>0 ? zeros(n, m) : zeros(0,0)

    # RSOC
    zR = r>0 ? zeros(n, r) : zeros(0,0)
    uR = r>0 ? zeros(n, r) : zeros(0,0)

    # disuguaglianze
    zA = na>0 ? zeros(n) : zeros(0)
    uA = na>0 ? zeros(n) : zeros(0)

    # clamp
    zU = nu>0 ? zeros(nu) : zeros(0)
    uU = nu>0 ? zeros(nu) : zeros(0)

    z_prev = copy(z)
    zR_prev = copy(zR)

    zU_prev = copy(zU)
    zA_prev = copy(zA)

    # ------------------------
    # Costruzione matrice Hx per l'update di x
    # ------------------------
    Hx = copy(H) 

    # 1️⃣ Contributo vincoli conici
    # SOC
    if m > 0
        for i in 1:m
            idx_vec = Soc.Ind_Soc[i]
            Hx[idx_vec, idx_vec] += ρ * I(length(idx_vec))
        end
        if mv > 0
            for i in 1:mv
                idx_scal = Soc.Ind_t_Soc[i]
                Hx[idx_scal, idx_scal] += ρ
            end
        end
    else
        sum_z_u = zeros(n)
    end

    # RSOC
    if r > 0
        for i in 1:r
            idx_vec = Rsoc.Ind_x[i]
            # idx_y   = Soc.Ind_u[i]
            # idx_z   = Soc.Ind_v[i]
            Hx[idx_vec, idx_vec] += ρ*I(length(idx_vec))
            # Hx[idx_y, idx_y] += ρ
            # Hx[idx_z, idx_z] += ρ
        end
    end

    # 2️⃣ Contributo vincoli di disuguaglianza Ax ≤ c
    if  na > 0
        for i in 1:n
            Hx[i,i] += ρ
        end
    end
 
    # 3️⃣ Contributo vincoli clamp
    if nu > 0
        for i in Box_ind
            Hx[i,i] += ρ
        end
    end

 
    # ------------------------
    # Fattorizzazioni (con o senza vincoli di uguaglianza)
    # ------------------------
    if F === nothing && size(F,1) == 0
        Hx_fact = factorize(Hx)
    else
        # KKT = [Hx F'; F zeros(size(F,1), size(F,1))]
        KKT = [sparse(Hx) F'; F spzeros(size(F,1), size(F,1))]
        KKT_fact = lu(KKT)
    end

    # ==========================================================
    # Iterazioni ADMM
    # ==========================================================
    for k in 1:max_iter

        # ------------------------
        # x-update
        # ------------------------
        extra_term = zeros(n)

        # Vincoli di disuguaglianza
        if  na > 0
            @views extra_term .+= zA - uA
        end

        # Clamp
        if nu > 0
            @views extra_term[n-nu+1:end] .+= zU - uU
        end

        # Coni
        if m > 0
            sum_z_u = zeros(n)
            for j in 1:m
                @views sum_z_u .+= z[:,j] .- u[:,j]
            end
        end

        if r>0
            if m<1
                sum_z_u = zeros(n)
            end

            for j in 1:r
                sum_z_u .+= zR[:,j] - uR[:,j]
            end
        end

        # RHS per il sistema lineare
        f = ρ*sum_z_u + ρ*extra_term - obj

        if  size(F,1) != 0
            # Risoluzione sistema KKT (con vincoli Fx = g)
            rhs = vcat(f, g)
            sol = KKT_fact \ rhs
            x = sol[1:n]
        else
            # Caso senza vincoli di uguaglianza
            x = Hx_fact \ f
        end

        if any(isnan, x)
            error("NaN rilevato in x-update")
        end

        # ------------------------
        # z-update (vincoli conici)
        # ------------------------
        if m > 0
            for i in 1:m
                idx_vec = Soc.Ind_Soc[i]
                if i <= mv
                    idx_scal = Soc.Ind_t_Soc[i]
                    z[idx_vec,i], z[idx_scal,i] = proj_soc(x[idx_vec] + u[idx_vec,i], x[idx_scal] + u[idx_scal,i], false)
                else
                    idx_scal = i - mv
                    z[idx_vec,i] = proj_soc(x[idx_vec] + u[idx_vec,i], Soc.t_Soc[idx_scal], true)
                end
            end
        end

        # ---------------- z-update RSOC
        if r>0
            for i in 1:r
                idx_vec = Rsoc.Ind_x[i]
                # idx_y   = Soc.Ind_u[i]
                # idx_z   = Soc.Ind_v[i]
                _ , _, a = proj_rsoc(Rsoc.Value_u[i], Rsoc.Value_v[i] , x[idx_vec]+uR[idx_vec,i], true, true)
                # a, _ = proj_soc(vcat(x[idx_vec] + uR[idx_vec,i], Rsoc.Value_v[i] - Rsoc.Value_u[i]), Rsoc.Value_u[i]+ Rsoc.Value_v[i])
                zR[idx_vec,i] = a
            #     zR[idx_vec,i] .= a[1]
             end
        end


        # ------------------------
        # z-update (vincoli Ax ≤ c)
        # ------------------------
        if  na > 0
            zA = proj_polytope(x + uA, A, c)
        end

        # ------------------------
        # z-update (Clamp: u_min ≤ u ≤ u_max)
        # ------------------------
        if nu > 0
            @views xU = x[Box_ind]
            zU .= clamp.(xU .+ uU, Ineq.rhs_BoxMin, Ineq.rhs_BoxMax)
        end

        # ------------------------
        # u-update
        # ------------------------
        if m > 0
            for i in 1:mv
                idx_vec = Soc.Ind_Soc[i]
                idx_scal = Soc.Ind_t_Soc[i]
                u[idx_vec,i] += x[idx_vec] - z[idx_vec,i]
                u[idx_scal,i]+= x[idx_scal] - z[idx_scal,i]
            end
            for i in mv+1:m
                idx_vec = Soc.Ind_Soc[i]
                u[idx_vec,i] += x[idx_vec] - z[idx_vec,i]
            end
        end

        if r>0
            for i in 1:r
                idx_vec = Rsoc.Ind_x[i]
                # idx_y   = Soc.Ind_u[i]
                # idx_z   = Soc.Ind_v[i]
                uR[idx_vec,i] += x[idx_vec] - zR[idx_vec,i]
                # uR[idx_y,i]   += x[idx_y]   - zR[idx_y,i]
                # uR[idx_z,i]   += x[idx_z]   - zR[idx_z,i]
            end
        end
        if  na > 0
            uA += x - zA
        end
        if nu > 0
            uU += xU - zU
        end

        # ------------------------
        # Controllo convergenza
        # ------------------------
        r_norm = 0.0

        # SOC
        if m > 0
            for i in 1:m
                idx_vec = Soc.Ind_Soc[i]
                r_norm += sum(norm.(x[idx_vec] - z[idx_vec,i]))
            end

            for i in 1:mv
                idx_vec = Soc.Ind_Soc[i]
                idx_scal = Soc.Ind_t_Soc[i]
                r_norm += sum(norm.(x[idx_vec] - z[idx_vec,i]))
                r_norm += sum(norm.(x[idx_scal] - z[idx_scal,i]))
            end
            for i in mv+1:m
                idx_vec = Soc.Ind_Soc[i]
                r_norm += sum(norm.(x[idx_vec] - z[idx_vec,i]))
            end
        end
        
        # RSOC
        if r > 0
            for i in 1:r
                idx_vec = Rsoc.Ind_x[i]
                # idx_y = Soc.Ind_u[i]
                # idx_z = Soc.Ind_v[i]
                r_norm += sum(norm.(x[idx_vec] - zR[idx_vec,i]))
                # r_norm += sum(norm.(x[idx_y] - zR[idx_y,i]))
                # r_norm += sum(norm.(x[idx_z] - zR[idx_z,i]))
            end
        end
        # Ax ≤ c
        if na > 0
            r_norm += norm(x - zA)
        end
        # Clamp
        if nu > 0
            r_norm += norm(x[Box_ind]-zU)
        end

        # Costruzione vettore z concatenato per tolleranza primale
        z_all = Float64[]
        if m > 0
            z_all = vcat(z_all, vec(z))
        end
        if r > 0
            z_all = vcat(z_all, vec(zR))
        end
        if na > 0
            z_all = vcat(z_all, zA)
        end
        if nu > 0
            z_all = vcat(z_all, zU)
        end
        rnorm = norm(z_all)

        # Tolleranza primale
        ε_pri = sqrt(n)*ε_abs + ε_rel*max(norm(x), norm(z_all))

        # ================================
        # Calcolo residui duali
        # ================================
        s_norm = 0.0
        if m > 0
            s_norm += norm(ρ * vec(z - z_prev))
        end
        if r > 0
            s_norm += norm(ρ * vec(zR - zR_prev))
        end
        if na > 0
            s_norm += norm(ρ * (zA - zA_prev))
        end
        if nu > 0
            s_norm += norm(ρ * (zU - zU_prev))
        end

        # Tolleranza duale
        ε_dual = sqrt(n)*ε_abs + ε_rel*norm(ρ*u)

        # ================================
        # Check stop
        # ================================
        if r_norm <= ε_pri && s_norm <= ε_dual
            println("✅ Converged at iteration $k (r_norm=$r_norm, s_norm=$s_norm)")
            break
        end

        # Aggiorna z_prev per il prossimo passo
        z_prev  .= z
        zR_prev .= zR
        zA_prev .= zA
        zU_prev .= zU

        # Messaggio se raggiunto max_iter
        if k == max_iter
            println("⚠️ Raggiunto il numero massimo di iterazioni ($max_iter) senza convergenza. r_norm=$r_norm, s_norm=$s_norm")
        end
    end

    # ==========================================================
    # Check generale di fattibilità
    # ==========================================================
    feasible = true

    # Vincoli conici
    for i in 1:length(Soc.Ind_Soc)
        if i <= mv
            dist = norm(x[Soc.Ind_Soc[i]]) - x[Soc.Ind_t_Soc[i]]
            if dist > tol
                println("⚠️ Violato vincolo conico: distanza = $dist")
                feasible = false
            end
        else
            dist = norm(x[Soc.Ind_Soc[i]]) - Soc.t_Soc[i]
            if dist > tol
                println("⚠️ Violato vincolo conico: distanza = $dist")
                feasible = false
            end
        end
    end
    #RSOC check
    for i in 1:r
            dist = norm(x[Rsoc.Ind_x[i]])^2 - 2*Rsoc.Value_u[i]*Rsoc.Value_v[i]
            if dist > tol
                println("⚠️ Violato vincolo conico: distanza = $dist")
                feasible = false
            end
    end

    # Vincoli lineari di uguaglianza
    if  size(F,1) != 0
        residual = norm(F * x - g)
        if residual > tol
            println("⚠️ Violati vincoli lineari di uguaglianza: residuo = $residual")
            feasible = false
        end
    end

    # Vincoli di disuguaglianza
    if na > 0
        viol = A * x - c
        if any(viol .> tol)
            println("⚠️ Violati vincoli di disuguaglianza: max violazione = $(maximum(viol))")
            feasible = false
        end
    end

    if nu > 0
        viol = abs.(x[Box_ind]).-0.2
        if any(viol .> tol)
            println("⚠️ Violati vincoli di Bound: max violazione = $(maximum(viol))")
            feasible = false
        end
    end

    return x, z
end
