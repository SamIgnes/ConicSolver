using LinearAlgebra
using Plots
using SparseArrays

include("FunctionsProjections")
include("ADMM Solver")

# ======================
# Parametri del problema
# ======================
function demo()
T = 7.5           # orizzonte temporale [s]
N = 30            # step di discretizzazione
dt = T/N

nx = 6*(N+1)      # stato: posizione (3) + velocità (3)
nu = 3*N          # input: thrust (3)

n = nx + nu

m0 = 0.35
g0 = 9.8

# ======================
# Dinamica lineare
# ======================

# Matrice A, B, h (discrete-time) dal modello 3DoF
A = [zeros(3,3)  I(3);
     zeros(3,3)  zeros(3,3)]

B = (1/m0) * [zeros(3,3);
              I(3)]

e = [0.0, 0.0, 1.0]              # unità verticale
h = vcat(zeros(3), -g0*e)        # 6 elementi: [0,0,0, 0,0,-g0]

# Matrice di vincoli di uguaglianza (dinamica + condizioni iniziali/finali)
F = zeros(6*N + 13, n)
g = zeros(6*N + 13)



row = 1
for k in 1:N

    # indici per r_k, s_k, r_{k+1}, s_{k+1}, u_k
    idx_rk   = 6*(k-1) + 1
    idx_sk   = 6*(k-1) + 4
    idx_rkp1 = 6*k + 1
    idx_skp1 = 6*k + 4
    idx_uk   = nx + 3*(k-1) + 1

    # ---- Vincolo posizione ----
    F[row:row+2, idx_rkp1:idx_rkp1+2] .= I(3)
    F[row:row+2, idx_rk:idx_rk+2]     .= -I(3)
    F[row:row+2, idx_sk:idx_sk+2]     .= -dt*I(3)
    F[row:row+2, idx_uk:idx_uk+2]     .= -(dt^2)/(2*m0) * I(3)
    g[row:row+2] .= -(dt^2/2)*g0*e
    row += 3

    # ---- Vincolo velocità ----
    F[row:row+2, idx_skp1:idx_skp1+2] .= I(3)
    F[row:row+2, idx_sk:idx_sk+2]     .= -I(3)
    F[row:row+2, idx_uk:idx_uk+2]     .= -(dt/m0)*I(3)
    g[row:row+2] .= -dt*g0*e
    row += 3
end


# Vincoli su stato iniziale
F[row:row+5, 1:6] .= I(6)
g[row:row+5] .= [ 0.0, 0.0, 0.0, 0, 0, 0 ]
row += 6  # stato iniziale (posizione target paper)
F[row:row+5, 6*N-5:6*N] .= I(6)
g[row:row+5] .= [ 2, 2, 0.0, 0, 0, 0 ]
row += 6  # stato finale (posizione target paper)

# Aggiungi una nuova riga in F e g

# Imposta i coefficienti sulla thrust finale
idx_u_final = nx + 3*(N-1) + 1 : nx + 3*(N-1) + 3
display(F[row, idx_u_final])
F[row, idx_u_final] = e
g[row] = m0 * g0
idx_u_final = nx + 3*(N-1) + 1 : nx + 3*(N-1) + 3
# ======================
# Funzione costo
# ======================

Q = zeros(6,6)
Q[1:3,1:3] .= I(3)
Q[4:6,4:6] .= 2.5*I(3)
R = 0.5*I(3)                      # peso su thrust

H = zeros(n,n)
for k in 1:N
    H[(6*k-5):(6*k), (6*k-5):(6*k)] .= Q
    H[nx+3*(k-1)+1:nx+3*k, nx+3*(k-1)+1:nx+3*k] .= R
end

obj = zeros(n)   # termine lineare nullo

# ======================
# Vincoli conici (thrust)
# ======================

θ = pi/4
ρ1 = 5.0
ρ2 = 2.0

# RSOC: ‖u‖ cosθ ≤ uᵀ e, ‖u‖ ≤ ρ1, uᵀ e ≥ ρ2
Soc = SOC([collect(nx+3*(k-1)+1:nx+3*k) for k in 1:N] , [], [ρ1 for k in 1:N])
# Rsoc = RSOC([ [nx+3*(k-1)+1:nx+3*k] for k in 1:N ],
#              [[0.0] for k in 1:N],
#              [],
#              [ρ1 for k in 1:N],
#              [n for k in 1:N],
#              [])

Rsoc = RSOC([],
             [],
             [],
             [],
             [],
             [])


# ======================
# Vincoli di stato (bounding box + ostacoli linearizzati)
# ======================
kswitch = Int(floor(N/2))   # metà orizzonte, puoi cambiare

rows = []
z0 = 0.0
yfin = 2.0

for k in 1:N+1
    idx_rk = 6*(k-1) + 1  # posizione (x,y,z)

    if k <= kswitch
        # === Primo tratto: tubo verticale su x=0 ===
        push!(rows, ([1 0 0],   1.0, idx_rk))    # x ≤ 1
        push!(rows, ([-1 0 0],  1.0, idx_rk))    # x ≥ -1
        push!(rows, ([0 0 1],   z0+0.5, idx_rk)) # z ≤ z0+0.5
        push!(rows, ([0 0 -1], -z0+0.5, idx_rk)) # z ≥ z0-0.5

    else
        # === Secondo tratto: tubo orizzontale su y=yfin ===
        push!(rows, ([0 1 0],   yfin+1.0, idx_rk))   # y ≤ yfin+1
        push!(rows, ([0 -1 0], -yfin+1.0, idx_rk))   # y ≥ yfin-1
        push!(rows, ([0 0 1],   z0+0.5, idx_rk))     # z ≤ z0+0.5
        push!(rows, ([0 0 -1], -z0+0.5, idx_rk))     # z ≥ z0-0.5
    end
end

nrows = length(rows)
Aineq = zeros(nrows, n)
bineq = zeros(nrows)

for (i,(a,b_,idx)) in enumerate(rows)
    Aineq[i, idx:idx+2] .= a'
    bineq[i] = b_
end

Ineq = INEQ([],[],[], Aineq, bineq)


# Ineq = INEQ([],[],[], zeros(0,0), [])

# ======================
# Parametri ADMM
# ======================

ρ = 1.0
max_iter = 20000
ε_abs = 1e-6
ε_rel = 1e-6
tol = 1e-4

x0 = zeros(n)

# ======================
# Risoluzione
# ======================

x_sol, z_sol = admm_socp(x0, Soc, Rsoc, obj, H, F, g, Ineq;
    ρ=ρ, max_iter=max_iter, ε_abs=ε_abs, ε_rel=ε_rel, tol=tol)

# ======================
# Estrazione soluzioni
# ======================

r_vals = [x_sol[6*k-5:6*k-3] for k in 1:N+1]  # posizioni
s_vals = [x_sol[6*k-2:6*k]   for k in 1:N+1]  # velocità
u_vals = [x_sol[nx+3*(k-1)+1:nx+3*k] for k in 1:N] # thrust

# ======================
# Plot
# ======================

t = 0:dt:T

p1 = plot( getindex.(r_vals, 1), getindex.(r_vals, 2) , xlabel="x", ylabel="y", title="Traiettoria quadrotor")
p2 = plot(t, getindex.(r_vals, 3), xlabel="t [s]", ylabel="z", title="Quota")
p3 = plot(t[1:end-1], [norm(u) for u in u_vals], xlabel="t [s]", ylabel="‖u‖", title="Thrust norm")
p4 = plot(t[1:end-1], [getindex.(u_vals, 1),getindex.(u_vals, 2),getindex.(u_vals, 3)], xlabel="t [s]", ylabel="‖u‖", title="Thrust norm")
p5 = plot( [getindex.(s_vals, 1),getindex.(s_vals, 2),getindex.(s_vals, 3)], xlabel="t [s]", ylabel="‖u‖", title="Velocity")

display(plot(p1, p2, p3, layout=(3,1), size=(700,1000)))
display(plot(p4,p5, layout=(2,1), size=(700,1000)))
end

demo()