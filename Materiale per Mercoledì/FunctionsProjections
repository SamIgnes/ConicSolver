# ================================================
# Proiezione su politopo { z : A z ≤ c } via duale + PGD
# ================================================

mutable struct INEQ
    Ind_NonNeg:: Vector{Int}  # Indici delle variabili con vincoli di non negatività
    Ind_Box:: Vector{Int}  # Indici delle variabili con vincoli box (min, max)
    rhs_BoxMin:: Vector{Float64}  # Valori t per i vincoli box Min
    rhs_BoxMax:: Vector{Float64}  # Valori t per i vincoli box Max
    Ind_InGen:: Vector{Vector{Int}}  # Indici delle variabili con vincoli generali 
    Coeff_InGen:: Vector{Vector{Float64}}  # Coefficienti per i vincoli generali
    rhs_inGen:: Vector{Float64}  # Valori t per i vincoli generali  
end

"""
    struct SOC

Represents a collection of Second-Order Cones (SOC).  

Each cone is defined by:  
- A set of indices corresponding to the variables inside the norm.  
- A single index corresponding to the `t` variable (the scalar part of the cone).  
"""

struct SOC
    Ind_Soc::Vector{Vector{Int}}  # Indices of the variables in the norm for each SOC
    Ind_t_Soc::Vector{Int}        # Indices of the corresponding t variables (one per SOC)
    t_Soc::Vector{Float64}
end



"""
    struct RSOC

Represents a collection of Rotated Second-Order Cones (RSOC).  

Each RSOC is defined by:
- `Ind_x`: indices of the vector variables x in the quadratic part.
- `Ind_u`: index of the scalar variable u (must be non-negative).
- `Ind_v`: index of the scalar variable v (must be non-negative).

The RSOC constraint is: `||x||^2 <= 2 * u * v`, with `u >= 0` and `v >= 0`.
"""
struct RSOC
    Ind_x::Vector{Vector{Int}}  # Indices of x variables for each RSOC
    Ind_u::Vector{Int}          # Indices of u variables
    Ind_v::Vector{Int}          # Indices of v variables
end


struct SOCP
    c::Vector{Float64}  # cost vector
    A::Matrix{Float64}  # equality constraint matrix
    b::Vector{Float64}  # equality constraint rhs
    Soc :: SOC   # per SOC
    Rsoc :: RSOC # per RSOC
    Ineq :: INEQ         # Inequality constraints 
end

function proj_polytope(v::Vector, A::Matrix, c::Vector; 
                       max_iter=500, tol=1e-8)

    m, n = size(A)
    λ = zeros(m)   # moltiplicatori duali
    Av = A * v

    # stima passo ottimale: 1 / L con L = ||A*A'||₂
    L = opnorm(A * A', 2)
    α = 1.0 / L

    for k in 1:max_iter
        # gradiente del duale: ∇f(λ) = A*A' λ - (Av - c)
        grad = (A * (A' * λ)) - (Av - c)

        # step di discesa con proiezione
        λ_new = λ - α * grad
        λ_new = max.(λ_new, 0.0)

        # controllo convergenza
        if norm(λ_new - λ) < tol
            λ = λ_new
            break
        end
        λ = λ_new
    end

    # ricostruzione soluzione primale
    z = v - A' * λ
    return z
end

function proj_rsoc(v::Vector)
    n = length(v)
    z = copy(v)
    t = norm(v[3:end])

    # Caso già nel cono
    if v[1] >= 0 && v[2] >= 0 && v[1]*v[2] >= t^2
        return v
    end

    # Caso origine / componenti negative
    if t == 0
        z[1] = max(v[1], 0)
        z[2] = max(v[2], 0)
        z[3:end] .= 0
        return z
    end

    # Caso generale
    s = (v[1] + v[2])
    if t^2 <= (s^2)/4 && s > 0
        alpha = (s + 2*t)/2
        z[1] = alpha
        z[2] = alpha
        z[3:end] .= alpha / t * v[3:end]
    else
        # t^2 > (v1+v2)^2/4
        z[1] = t
        z[2] = t
        # z[3:n] rimane invariato
    end
    return z
end

function proj_soc(u::AbstractVector, t::Real)
    if length(u) > 1
        nx = norm(u)
        if nx <= t
            return copy(u), t
        else
            alpha = (nx + t) / (2nx)
            return alpha * u, (nx + t)/2
        end
    else
        # caso scalare: cono [-t, t]
        return clamp.(u, -t, t)
    end
end

