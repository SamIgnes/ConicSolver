# ================================================
# Proiezione su politopo { z : A z â‰¤ c } via duale + PGD
# ================================================

struct INEQ
    Ind_NonNeg:: Vector{Int}  # Indici delle variabili con vincoli di non negativitÃ 
    Ind_Box:: Vector{Int}  # Indici delle variabili con vincoli box (min, max)
    rhs_BoxMin:: Vector{Float64}  # Valori t per i vincoli box Min
    rhs_BoxMax:: Vector{Float64}  # Valori t per i vincoli box Max
    # Ind_A:: Vector{Vector{Int}}  # Indici delle variabili con vincoli generali 
    # Coeff_A:: Vector{Vector{Float64}}  # Coefficienti per i vincoli generali
    A:: Matrix{Float64}
    rhs_c:: Vector{Float64}  # Valori t per i vincoli generali  
end

"""
    struct SOC

Represents a collection of Second-Order Cones (SOC).  

Each cone is defined by:  
- A set of indices corresponding to the variables inside the norm.  
- A single index corresponding to the `t` variable (the scalar part of the cone).  
"""

struct SOC
    Ind_Soc::Vector{Vector{Int}}  # Indices of the variables in the norm for each SOC
    Ind_t_Soc::Vector{Int}        # Indices of the corresponding t variables (one per SOC)
    t_Soc::Vector{Float64}
end



"""
    struct RSOC

Represents a collection of Rotated Second-Order Cones (RSOC).  

Each RSOC is defined by:
- `Ind_x`: indices of the vector variables x in the quadratic part.
- `Ind_u`: index of the scalar variable u (must be non-negative).
- `Ind_v`: index of the scalar variable v (must be non-negative).

The RSOC constraint is: `||x||^2 <= 2 * u * v`, with `u >= 0` and `v >= 0`.
"""

struct RSOC
    Ind_x::Vector{Vector{Int}}  # Indices of x variables for each RSOC
    Shift_x::Vector{Vector{Float64}} # Shift of x for each variables of each RSOC
    Ind_u::Vector{Int}          # Indices of u variables
    Value_u::Vector{Float64}    # 
    Ind_v::Vector{Int}          # Indices of v variables
    Value_v::Vector{Float64}    # 
end


struct SOCP
    c::Vector{Float64}  # cost vector
    A::Matrix{Float64}  # equality constraint matrix
    b::Vector{Float64}  # equality constraint rhs
    Soc :: SOC   # per SOC
    Rsoc :: RSOC # per RSOC
    Ineq :: INEQ         # Inequality constraints 
end

function proj_polytope_dual(v::Vector, A::Matrix, c::Vector; 
                             max_iter=500, tol=1e-8)

    m, n = size(A)   # m = numero vincoli, n = numero variabili
    Î» = zeros(m)     # moltiplicatori duali
    # v Ã¨ giÃ  A*x + uA

    # stima passo ottimale: 1 / L con L = ||A*A'||â‚‚
    L = opnorm(A * A', 2)
    Î± = 1.0 / L

    for k in 1:max_iter
        # gradiente del duale: âˆ‡f(Î») = A*A' Î» - (v - c)
        grad = (A * (A' * Î»)) - (v - c)

        # step di discesa con proiezione
        Î»_new = Î» - Î± * grad
        Î»_new = max.(Î»_new, 0.0)

        # controllo convergenza
        if norm(Î»_new - Î») < tol
            Î» = Î»_new
            break
        end
        Î» = Î»_new
    end

    # ricostruzione soluzione primale nello spazio dei vincoli
    # zA = v - A*(A'*Î»)
    zA = v - (A * (A' * Î»))  # mantiene dimensione m
    return zA
end


function proj_polytope(v::Vector, A::Matrix, c::Vector; 
                       max_iter=500, tol=1e-8)

    m, n = size(A)
    Î» = zeros(m)   # moltiplicatori duali
    Av = A * v

    # stima passo ottimale: 1 / L con L = ||A*A'||â‚‚
    L = opnorm(A * A', 2)
    Î± = 1.0 / L

    for k in 1:max_iter
        # gradiente del duale: âˆ‡f(Î») = A*A' Î» - (Av - c)
        grad = (A * (A' * Î»)) - (Av - c)

        # step di discesa con proiezione
        Î»_new = Î» - Î± * grad
        Î»_new = max.(Î»_new, 0.0)

        # controllo convergenza
        if norm(Î»_new - Î») < tol
            Î» = Î»_new
            break
        end
        Î» = Î»_new
    end

    # ricostruzione soluzione primale
    z = v - A' * Î»
    return z
end

"""
    proj_rsoc(u, w, x; fixed_u=false, fixed_w=false)

Proietta (u,w,x) sul Rotated Second Order Cone:

    K = { (u,w,x) : u >= 0, w >= 0, 2uw >= ||x||^2 }

Opzioni:
- fixed_u = true â†’ u Ã¨ fissato, non viene modificato
- fixed_w = true â†’ w Ã¨ fissato, non viene modificato
"""
function proj_rsoc(u, w, x, fixed_u, fixed_w)
    t = norm(x)

    #  Caso entrambi fissati â†’ clamp radiale su x
    if fixed_u && fixed_w
        r2 = 2*u*w
        if r2 < 0
            return u, w, zero(x)
        elseif t^2 <= r2
            return u, w, x
        else
            return u, w, sqrt(r2) * (x / t)
        end
    end

    #  Caso u fissato, w variabile
    if fixed_u && !fixed_w
        r2 = 2*u*w
        if r2 < 0
            return u, max(0.0,w), zero(x)
        elseif t^2 <= r2 && w >= 0
            return u, w, x
        else
            # Clamp radiale su x e aggiustamento minimo di w
            x_new = sqrt(max(0.0,2*u*max(w,0))) * (x/t)
            w_new = max(w, (t^2)/(2*max(u,1e-12)))
            return u, w_new, x_new
        end
    end

    #  Caso w fissato, u variabile
    if fixed_w && !fixed_u
        r2 = 2*u*w
        if r2 < 0
            return max(0.0,u), w, zero(x)
        elseif t^2 <= r2 && u >= 0
            return u, w, x
        else
            # Clamp radiale su x e aggiustamento minimo di u
            x_new = sqrt(max(0.0,2*w*max(u,0))) * (x/t)
            u_new = max(u, (t^2)/(2*max(w,1e-12)))
            return u_new, w, x_new
        end
    end

    # ðŸ”¹ Caso generale: entrambi variabili
    u1, w1, x1 = copy(u), copy(w), copy(x)

    if u >= 0 && w >= 0 && 2u*w >= t^2
        return u, w, x
    end

    if t == 0
        u1 = max(u, 0)
        w1 = max(w, 0)
        x1 .= 0
        return u1, w1, x1
    end

    # Heuristic projection (come nella tua versione)
    s = u + w
    if t^2 <= (s^2)/4 && s > 0
        alpha = (s + 2*t)/2
        u1, w1 = alpha, alpha
        x1 .= (alpha/t) * x
    else
        beta = t/sqrt(2)
        u1, w1 = max(beta,0.0), max(beta,0.0)
        x1 .= (u1/t) * x
    end

    return u1, w1, x1
end



function proj_soc(u::AbstractVector, t::Real, fixed_t::Bool)
    if !fixed_t
        # ----- Caso variabile -----
        nx = norm(u)
        if nx <= t
            return copy(u), t
        elseif nx <= -t
            return zeros(length(u)), 0.0
        else
            Î± = (nx + t) / (2nx)
            return Î± * u, (nx + t) / 2
        end
    else
        # ----- Caso fisso -----
        nx = norm(u)
        if nx <= t
            return copy(u), t
        else
            return (t / nx) * u, t
        end
    end
end

