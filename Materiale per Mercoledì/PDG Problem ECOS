using JuMP, SCS
using Plots
using LinearAlgebra
using TickTock
using BenchmarkTools

# Dati (esempio: sostituisci con i tuoi)
tick()
N = 72
Δt = 1.0
Isp = 225
g  = [0.0, 0.0, -3.711]     # m/s^2 (Marte) come vettore
φ = 27*(π/180)  # angolo di inclinazione del motore
α  = 1/(Isp*9.80665*cos(φ)) # calcola in base ai tuoi parametri
T = 6 * 3.1e3
ρ1 = 0.3*T
ρ2 = 0.8*T
m_wet   = 1905.0
β     = tand(1)
r0 = [2000, 0.0, 1500] # posizione iniziale (m)
v0 = [100.0, 0.0, -75.0]      # velocità iniziale (m/s)
z0_init = log(m_wet)

# Precompute z0_k, μ1_k, μ2_k
z0k  = [log(m_wet - α*ρ2*(k*Δt)) for k in 0:N]
μ1k  = [ρ1*exp(-z0k[k+1]) for k in 0:N]
μ2k  = [ρ2*exp(-z0k[k+1]) for k in 0:N]
zmax = [log(m_wet - α*ρ1*(k*Δt)) for k in 0:N]

model = Model(SCS.Optimizer)
set_silent(model)

# Variabili
@variable(model, u[0:N,1:3])
@variable(model, σ[0:N] >= 0)
@variable(model, r[0:N,1:3])
@variable(model, v[0:N,1:3])
@variable(model, z[0:N])
@variable(model, tquad[0:N] >= 0)  # per (z - z0k)^2

# Dinamica
for k in 0:N-1
    @constraint(model, r[k+1,:] .== r[k,:] .+ (Δt/2)*(v[k,:] .+ v[k+1,:]) .- (Δt^2/12)*(u[k+1,:] .- u[k,:]))
    @constraint(model, v[k+1,:] .== v[k,:] .+ (Δt/2)*(u[k,:] .+ u[k+1,:]) .+ Δt*g)
    @constraint(model, z[k+1] == z[k] - (α*Δt/2)*(σ[k] + σ[k+1]))
end

# Coni: ||u_k|| ≤ σ_k
for k in 0:N
    @constraint(model, [σ[k]; u[k,1]; u[k,2]; u[k,3]] in SecondOrderCone())
end

for k in 1:2
    @constraint(model, u[N,k] == 0 )
end
# Rotated SOC per tquad[k] ≥ (z[k]-z0k)^2
# y ≥ x^2  ⇔  (y, 1/2, x) ∈ RotatedSecondOrderCone
for k in 0:N
    @constraint(model, [tquad[k], 0.5, z[k]-z0k[k+1]] in RotatedSecondOrderCone())
end

# Vincoli su σ_k (inferiore e superiore)
for k in 0:N
    @constraint(model, μ1k[k+1]*(1 - (z[k]-z0k[k+1]) + 0.5*tquad[k]) <= σ[k])
    @constraint(model, σ[k] <= μ2k[k+1]*(1 - (z[k]-z0k[k+1])))
end

# Bounds su z
for k in 0:N
    @constraint(model, z0k[k+1] <= z[k] <= zmax[k+1])
end

# Glide-slope sui nodi: ||r_d|| ≤ β r_v  (assumi e3 = asse verticale)
# for k in 0:N
#     @constraint(model, [β*(r[k,3]); r[k,1]; r[k,2]] in SecondOrderCone())
# end

# # (Opzionale) vincolo inter-sample glide-slope (eq. (7) nel paper) usando v[k]
# # || r_dk + (2Δt/3) v_dk || ≤ β * ( r_vk + (2Δt/3) v_vk )
# for k in 0:N
#     @constraint(model, [β*(r[k,3] + (2Δt/3)*v[k,3]); r[k,1] + (2Δt/3)*v[k,1]; r[k,2] + (2Δt/3)*v[k,2]] in SecondOrderCone())
# end

# Condizioni iniziali e finali
@constraint(model, r[0,:] .== r0)
@constraint(model, v[0,:] .== v0)
@constraint(model, z[0]    == z0_init)
@constraint(model, r[N,:]  .== [0.0, 0.0, 0.0])
@constraint(model, v[N,:]  .== [0.0, 0.0, 0.0])

# Costo: min -z_N  (=> massimizza massa finale)
@objective(model, Min, -z[N])

tock()

@btime optimize!(model)



vec = norm(collect(value.(u)))

# Recupero soluzioni: value.(u), value.(r), value.(v), exp(value(z[N])) = m_finale

display(plot(collect(value.(u)), title="Controllo u", xlabel="Step", ylabel="u", legend=:topright))
display(plot(collect(value.(σ)), title="Controllo norm u", xlabel="Step", ylabel="u", legend=:topright))
display(plot(0:N, exp.(collect(value.(z))), seriestype=:line, title="Mass", xlabel="Step", ylabel="Mass", legend=:topright))
display(plot(exp.(collect(value.(z))) .* collect(value.(σ)), title="Thrust Norm", xlabel="Step", ylabel="z", legend=:topright))
display(plot(collect(value.(r)), title="Posizione r", xlabel="Step", ylabel="r", legend=:topright))
display(plot(collect(value.(v)), title="Velocità v", xlabel="Step", ylabel="v", legend=:topright))
println("Massa finale = ", exp(value(z[N])))    
