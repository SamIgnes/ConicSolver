using JuMP, SCS, LinearAlgebra
using Plots

"""
Successive Convexification per powered descent con drag.
- N: numero di steps
- max_iter: numero massimo iterazioni SCvx
- trust: se true usa aggiornamento tipo trust-region, altrimenti Newton-like
"""
function successive_convexification(N, max_iter; trust=true)

    # === Parametri fisici ===
    Isp = 225.0
    g  = [0.0, 0.0, -3.711]          # gravità marziana
    φ  = 27*(π/180)                  # inclinazione motore
    α  = 1/(Isp*9.80665*cos(φ))      # coefficiente consumo propellente
    T  = 6 * 3.1e3
    m_wet = 1905.0
    ρ1 = 0.3*T
    ρ2 = 0.8*T 
    r0, v0 = [2000.0,0.0,1500.0], [100.0,0.0,-75.0]
    z0_init = log(m_wet)

    # === Parametri drag ===
    ρatm, Cd, A = 0.015, 1.5, 10.0

    # === Guess iniziale ===
    tf = 72.0
    Δt = tf/N


    # Precompute z0_k, μ1_k, μ2_k
    z0k  = [log(m_wet - α*ρ2*(k*Δt)) for k in 0:N]
    μ1k  = [ρ1*exp(-z0k[k+1]) for k in 0:N]
    μ2k  = [ρ2*exp(-z0k[k+1]) for k in 0:N]
    zmax = [log(m_wet - α*ρ1*(k*Δt)) for k in 0:N]

    model = Model(SCS.Optimizer)
    set_silent(model)

    # Variabili
    @variable(model, u[0:N,1:3])
    @variable(model, σ[0:N] >= 0) #Non servono >=
    @variable(model, r[0:N,1:3])
    @variable(model, v[0:N,1:3])
    @variable(model, z[0:N])
    @variable(model, tquad[0:N] >= 0)  # per (z - z0k)^2 #Non servono >=

    # Dinamica
    for k in 0:N-1
        @constraint(model, r[k+1,:] .== r[k,:] .+ (Δt/2)*(v[k,:] .+ v[k+1,:]) .- (Δt^2/12)*(u[k+1,:] .- u[k,:]))
        @constraint(model, v[k+1,:] .== v[k,:] .+ (Δt/2)*(u[k,:] .+ u[k+1,:]) .+ Δt*g)
        @constraint(model, z[k+1] == z[k] - (α*Δt/2)*(σ[k] + σ[k+1]))
    end

    # Coni: ||u_k|| ≤ σ_k
    for k in 0:N
        @constraint(model, [σ[k]; u[k,1]; u[k,2]; u[k,3]] in SecondOrderCone())
    end

    for k in 1:2
        @constraint(model, u[N,k] == 0 )
    end
    # Rotated SOC per tquad[k] ≥ (z[k]-z0k)^2
    # y ≥ x^2  ⇔  (y, 1/2, x) ∈ RotatedSecondOrderCone
    for k in 0:N
        @constraint(model, [tquad[k], 0.5, z[k]-z0k[k+1]] in RotatedSecondOrderCone())
    end

    # # Vincoli su σ_k (inferiore e superiore)
    for k in 0:N
        @constraint(model, μ1k[k+1]*(1 - (z[k]-z0k[k+1]) + 0.5*tquad[k]) <= σ[k])
        @constraint(model, σ[k] <= μ2k[k+1]*(1 - (z[k]-z0k[k+1])))
    end

    # Bounds su z
    for k in 0:N
        @constraint(model, z0k[k+1] <= z[k] <= zmax[k+1])
    end

    # Glide-slope sui nodi: ||r_d|| ≤ β r_v  (assumi e3 = asse verticale)
    # for k in 0:N
    #     @constraint(model, [β*(r[k,3]); r[k,1]; r[k,2]] in SecondOrderCone())
    # end

    # # (Opzionale) vincolo inter-sample glide-slope (eq. (7) nel paper) usando v[k]
    # # || r_dk + (2Δt/3) v_dk || ≤ β * ( r_vk + (2Δt/3) v_vk )
    # for k in 0:N
    #     @constraint(model, [β*(r[k,3] + (2Δt/3)*v[k,3]); r[k,1] + (2Δt/3)*v[k,1]; r[k,2] + (2Δt/3)*v[k,2]] in SecondOrderCone())
    # end

    # Condizioni iniziali e finali
    @constraint(model, r[0,:] .== r0)
    @constraint(model, v[0,:] .== v0)
    @constraint(model, z[0]    == z0_init)
    @constraint(model, r[N,:]  .== [0.0, 0.0, 0.0])
    @constraint(model, v[N,:]  .== [0.0, 0.0, 0.0])

    # Costo: min -z_N  (=> massimizza massa finale)
    @objective(model, Min, -z[N])


    optimize!(model)

    r_nom = collect(value.(r))
    v_nom = collect(value.(v))
    z_nom = collect(value.(z))


    println("m_final = ", exp(z_nom[end]))

    σ_nom = collect(value.(σ))
    u_nom = collect(value.(u))
    t_nom = collect(value.(tquad))

    vec = norm(collect(value.(u)))

    m_final_prev = exp(z_nom[end])

    # # Recupero soluzioni: value.(u), value.(r), value.(v), exp(value(z[N])) = m_finale



    for iter in 1:max_iter
        model = Model(SCS.Optimizer)
        set_silent(model)

        # === Variabili ===
        @variable(model, r[0:N,1:3])
        @variable(model, v[0:N,1:3])
        @variable(model, z[0:N])
        @variable(model, u[0:N,1:3])
        @variable(model, σ[0:N] >= 0)
        @variable(model, tquad[0:N] >= 0)  # per (z - z0k)^2 #Non servono >=

        set_start_value.(r, r_nom)   # r_sol salvato dall'iterazione precedente
        set_start_value.(v, v_nom)
        set_start_value.(u, u_nom)
        set_start_value.(z, z_nom)
        set_start_value.(σ, σ_nom)
        set_start_value.(tquad, t_nom)

        # Dinamica linearizzata
        for k in 0:N-1
            vk = v_nom[k+1,:]
            mk = exp(z_nom[k+1])
            vnorm = norm(vk) + 1e-6
            d_nom = -0.5*ρatm*Cd*A*vnorm/mk * vk
            Jd = -0.5*ρatm*Cd*A/mk * ((vnorm*I(3)) + (vk*vk')/vnorm)

            @constraint(model, r[k+1,:] .== r[k,:] + Δt*v[k,:])
            @constraint(model, v[k+1,:] .== v[k,:] + Δt*(u[k,:] + g + d_nom + Jd*(v[k,:]-vk)))
            @constraint(model, z[k+1]   == z[k] - α*Δt*σ[k])
            @constraint(model, [σ[k]; u[k,1]; u[k,2]; u[k,3]] in SecondOrderCone())
        end

        # Condizioni iniziali/finali
        @constraint(model, r[1,:] .== r0)
        @constraint(model, v[1,:] .== v0)
        @constraint(model, z[1]   == z0_init)
        @constraint(model, r[end,:] .== [0,0,0])
        @constraint(model, v[end,:] .== [0,0,0])

        # Coni: ||u_k|| ≤ σ_k
        for k in 0:N
            @constraint(model, [σ[k]; u[k,1]; u[k,2]; u[k,3]] in SecondOrderCone())
        end

        for k in 1:2
            @constraint(model, u[N,k] == 0 )
        end
        # Rotated SOC per tquad[k] ≥ (z[k]-z0k)^2
        # y ≥ x^2  ⇔  (y, 1/2, x) ∈ RotatedSecondOrderCone
        for k in 0:N
            @constraint(model, [tquad[k], 0.5, z[k]-z0k[k+1]] in RotatedSecondOrderCone())
        end

        # # Vincoli su σ_k (inferiore e superiore)
        for k in 0:N
            @constraint(model, μ1k[k+1]*(1 - (z[k]-z0k[k+1]) + 0.5*tquad[k]) <= σ[k])
            @constraint(model, σ[k] <= μ2k[k+1]*(1 - (z[k]-z0k[k+1])))
        end

        # Bounds su z
        for k in 0:N
            @constraint(model, z0k[k+1] <= z[k] <= zmax[k+1])
        end

        if iter > 1
            # Trust Region Constraint
            # Δr = 100
            # Δv = 10
            @variable(model, s[0:N])
            Δu = 0.6
            for k in 0:N
                # @constraint(model, [Δr; r[k,1] - r_nom[k+1,1]; r[k,2] - r_nom[k+1,2]; r[k,3] - r_nom[k+1,3]] in SecondOrderCone())
                # @constraint(model, [Δv; v[k,1] - v_nom[k+1,1]; v[k,2] - v_nom[k+1,2]; v[k,3] - v_nom[k+1,3]] in SecondOrderCone())
                @constraint(model, [Δu + s[k]; u[k,1] - u_nom[k+1,1]; u[k,2] - u_nom[k+1,2]; u[k,3] - u_nom[k+1,3]] in SecondOrderCone())
            end
            # set_start_value.(s, zeros(N+1))
            @objective(model, Min, -z[end]+1500*sum(s)^2)
        else
            @objective(model, Min, -z[end])
        end




        # Costo: massimizzare massa finale
        

        optimize!(model)

        # === Recupera soluzione ===
        r_sol = collect(value.(r))
        v_sol = collect(value.(v))
        z_sol = collect(value.(z))
        J = -objective_value(model)   # massa finale (log)

        # Parametro di damping
        λ = 0.5

        # === Aggiornamento traiettoria nominale con damping ===
        for k in 0:N
            r_nom[k+1, :] = (1 - λ) * r_nom[k+1, :] + λ * r_sol[k+1, :]
            v_nom[k+1, :] = (1 - λ) * v_nom[k+1, :] + λ * v_sol[k+1, :]
            z_nom[k+1]   = (1 - λ) * z_nom[k+1]   + λ * z_sol[k+1]
        end

        # # === Aggiornamento traiettoria nominale ===
        # r_nom, v_nom, z_nom = r_sol, v_sol, z_sol

        # # === Aggiornamento tf ===
        # if trust
        #     # Trust-region: se migliora accetto tf più piccolo
        #     Δtf = -0.05*tf   # prova a ridurre di 5%
        #     tf_new = max(5.0, tf + Δtf)
        # else
        #     if iter > 1
        #         # Newton-like: usa gradiente approssimato (fin diff)
        #         eps = 1e-2
        #         J_plus = J
        #         tf_plus = tf + eps
        #         Δt_plus = tf_plus/N
        #         # stima derivata ∂J/∂tf ~ (J(tf+eps) - J(tf))/eps
        #         # NB: qui per semplicità uso proporzionale
        #         dJdt = (J_plus - J)/eps
        #         Δtf = - J/dJdt
        #         tf_new = max(5.0, tf + 0.5*Δtf)  # step damping
        #     else
        #         tf_new = 
        #     end
        # end

        # Δt = tf_new/N
        # tf = tf_new

        tol = 1e-8
        if abs(exp(z_sol[end]) - m_final_prev)/m_final_prev < tol
            println("Convergenza raggiunta alla iterazione $iter")
            break
        end
        m_final_prev = exp(z_sol[end])

        println("Iter $iter: tf = $tf, m_final = ", exp(z_sol[end]))
    end

    p1 = plot(collect(value.(u)), title="Controllo u", xlabel="Step", ylabel="u", legend=:topright)
    p2 = plot(collect(value.(σ)), title="Controllo norm u", xlabel="Step", ylabel="u", legend=:topright)
    p3 = plot(exp.(collect(value.(z))), seriestype=:line, title="Mass", xlabel="Step", ylabel="Mass", legend=:topright)
    p4 = plot(exp.(collect(value.(z))) .* collect(value.(σ))/T, title="Thrust Norm", xlabel="Step", ylabel="z", legend=:topright)
    p5 = plot(collect(value.(r)), title="Posizione r", xlabel="Step", ylabel="r", legend=:topright)
    p6 = plot(collect(value.(v)), title="Velocità v", xlabel="Step", ylabel="v", legend=:topright)
    display(plot(p5,p6,p3, layout=(3,1), size=(700,1000)))
    display(plot(p1,p2,p4, layout=(3,1), size=(700,1000)))
end

# Esegui
successive_convexification(72, 100, trust=true)
