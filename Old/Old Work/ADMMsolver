using LinearAlgebra
include("ProjectionsADMM")


struct INEQ
    Ind_NonNeg:: Vector{Int}  # Indici delle variabili con vincoli di non negatività
    Ind_Box:: Vector{Int}  # Indici delle variabili con vincoli box (min, max)
    rhs_BoxMin:: Vector{Float64}  # Valori t per i vincoli box Min
    rhs_BoxMax:: Vector{Float64}  # Valori t per i vincoli box Max
    Ind_InGen:: Vector{Int}  # Indici delle variabili con vincoli generali 
    rhs_inGen:: Vector{Float64}  # Valori t per i vincoli generali  
end

"""
    struct SOC

Represents a collection of Second-Order Cones (SOC).  

Each cone is defined by:  
- A set of indices corresponding to the variables inside the norm.  
- A single index corresponding to the `t` variable (the scalar part of the cone).  
"""

struct SOC
    Ind_Soc::Vector{Vector{Int}}  # Indices of the variables in the norm for each SOC
    Ind_t_Soc::Vector{Int}        # Indices of the corresponding t variables (one per SOC)
end


"""
    struct RSOC

Represents a collection of Rotated Second-Order Cones (RSOC).  

Each RSOC is defined by:
- `Ind_x`: indices of the vector variables x in the quadratic part.
- `Ind_u`: index of the scalar variable u (must be non-negative).
- `Ind_v`: index of the scalar variable v (must be non-negative).

The RSOC constraint is: `||x||^2 <= 2 * u * v`, with `u >= 0` and `v >= 0`.
"""
struct RSOC
    Ind_x::Vector{Vector{Int}}  # Indices of x variables for each RSOC
    Ind_u::Vector{Int}          # Indices of u variables
    Ind_v::Vector{Int}          # Indices of v variables
end


struct SOCP
    c::Vector{Float64}  # cost vector
    A::Matrix{Float64}  # equality constraint matrix
    b::Vector{Float64}  # equality constraint rhs
    Soc :: SOC   # per SOC
    Rsoc :: RSOC # per RSOC
    Ineq :: INEQ         # Inequality constraints 
end




export admm_socp, SOCP, SOC, RSOC, INEQ
# ------------------------------------------------------------------------------
# ADMM solver
# ------------------------------------------------------------------------------

function admm_socp(prob::SOCP; ρ=1.0, max_iter=10000,rtol=1e-4, atol=1e-4, verbose=true)
    """
     admm_socp(prob::SOCP; ρ = 1.0, max_iter = 10_000,
       rtol = 1e-4, atol = 1e-4, verbose = true)
        Solves `prob` with ADMM and returns `(x, history)`.
        `history` is a Dict with primal/dual residual norms for plotting / inspection.
    """


    # unpack problem
    c, A, b, Soc, Rsoc, Ineq  = prob.c, prob.A, prob.b, prob.Soc, prob.Rsoc, prob.Ineq
    n = length(c)
    m = size(A, 1)

    # precompute KKT factorisation for the x‑subproblem
    K = [ρ*Matrix{Float64}(I, n, n)  A'; 
         A                          zeros(m, m)]
    F = lu(K)      # factor once

    # initialise variables
    x = zeros(n);  z = copy(x);  u = zeros(n)

    # iteration history
    hist = Dict(:r_norm=>Float64[], :s_norm=>Float64[])

    for k in 1:max_iter
        # ----- 1. x‑update (quadratic + equality) -----------------------------
        rhs = vcat(ρ*(z - u) - c, b)
        sol = F \ rhs
        x   = sol[1:n]

        # ----- 2. z‑update (projection onto K) -------------------------------
        v = x + u
        z_old = copy(z) 
        z = projSOCP(v, Soc, Rsoc, Ineq)

        # ----- 3. dual update -----------------------------------------------
        u += x - z

        # ----- diagnostics ---------------------------------------------------
        r_norm = norm(x - z)                  # primal residual
        s_norm = ρ * norm(z - z_old)      # dual residual (simplifies)
        push!(hist[:r_norm], r_norm)
        push!(hist[:s_norm], s_norm)

        eps_pri = sqrt(n)*atol + rtol*max(norm(x), norm(z))
        eps_du  = sqrt(n)*atol + rtol*norm(ρ*u)


        if verbose && k % 100 == 0
            @info "iter $k  r = $(round(r_norm, sigdigits=3))  " *
                  "s = $(round(s_norm, sigdigits=3))"
        end
        if r_norm ≤ eps_pri && s_norm ≤ eps_du
            verbose && @info "Converged in $k iterations"
            return x, hist
        end
    end
    @warn "ADMM reached max_iter = $max_iter without convergence"
    return z, hist
end

end