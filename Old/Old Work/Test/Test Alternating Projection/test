# proiezione_completa.jl
using LinearAlgebra
using TickTock

# --- Proiezione sul cono di Lorentz per (sigma, u) ---
# Restituisce sigma_proiettato (u è fisso)
function proj_soc_sigma_u(σ_hat, u_hat)
    nu = norm(u_hat)
    if nu <= σ_hat
        return σ_hat, u_hat
    elseif nu <= -σ_hat
        return 0.0, zeros(size(u_hat))
    else
        σ_proj = 0.5*(σ_hat + nu)
        u_proj = σ_proj * u_hat / nu
        return σ_proj, u_proj
    end
end

# --- Proiezione sull'epigrafo t >= (z-z0)^2 usando Newton su z ---
# Dati: z_hat, t_hat, z0, bounds zmin,zmax
# Restituisce (z_proj, t_proj)
function proj_epigraph_quadratic(z_hat, t_hat, z0, zmin=-Inf, zmax=Inf,
                                 tol=1e-10, maxit=200)
    s_hat = z_hat - z0
    # se già fattibile
    if t_hat >= s_hat^2 && z_hat >= zmin && z_hat <= zmax
        return z_hat, t_hat
    end

    # inizializzazione per Newton:
    # se t_hat >= 0, un buon guess è z0 + sign(s_hat)*sqrt(max(t_hat,0))
    if t_hat >= 0
        z = z0 + (s_hat == 0 ? 0.0 : sign(s_hat)*sqrt(t_hat))
    else
        z = clamp(z_hat, zmin, zmax)
    end

    for it = 1:maxit
        s = z - z0
        # funzione F(z) = ( (z-z0)^2 - t_hat )^2 + (z - z_hat)^2
        f = 4*s*(s^2 - t_hat) + 2*(z - z_hat)          # derivative
        df = 12*s^2 - 4*t_hat + 2                       # second derivative
        # safeguard
        if abs(df) < 1e-12
            # fallback small step
            dz = -f * 1e-3
        else
            dz = - f / df
        end
        # step limit for stability
        if !isfinite(dz)
            dz = sign(f)*1e-6
        elseif abs(dz) > 1.0
            dz = sign(dz)*1.0
        end
        z_new = z + dz
        # enforce z box
        z_new = clamp(z_new, zmin, zmax)
        if abs(z_new - z) < tol
            z = z_new
            break
        end
        z = z_new
    end

    t = (z - z0)^2
    return z, t
end

# --- main: alternate projections ---
"""
proj_sigma_z_t_alt(hatσ, hatz, hatt, u; μ1, μ2, z0, zmin, zmax, maxiter, tol)

Alternate projections onto:
 1) SOC: σ >= ||u||
 2) Epigraph parabola + box on z: t >= (z-z0)^2 and zmin <= z <= zmax
 3) Clamp σ with lower/upper depending on (z,t):
       lower = μ1*(1 - (z-z0) + 0.5*t)
       upper = μ2*(1 - (z-z0))

Returns (σ_proj, z_proj, t_proj).
"""   
function proj_sigma_z_t_alt(hatσ, hatz, hatt, u, μ1, μ2, z0,
                            zmin=-Inf, zmax=Inf, maxiter=200, tol=1e-9)

    # initialize
    σ = hatσ
    z = clamp(hatz, zmin, zmax)
    t = max(hatt, (z - z0)^2)   # initial feasible-ish for t
    # if hatt smaller than parabola, we set t accordingly after first epigraph projection

    for it = 1:maxiter
        σ_prev, z_prev, t_prev, u_prev = σ, z, t, u

        # 1) proj SOC on (σ,u) -> updates only σ
        σ,u = proj_soc_sigma_u(σ, u)

        # 2) proj epigraph t >= (z-z0)^2 with box on z -> updates z,t
        # we call the Newton-based routine with current z,t as starting info
        z_proj, t_proj = proj_epigraph_quadratic(z, t, z0, zmin, zmax, 1e-10, 200)
        z, t = z_proj, t_proj

        # 3) clamp σ using bounds computed from new (z,t)
        lower = μ1*(1 - (z - z0) + 0.5*t)
        upper = μ2*(1 - (z - z0))
        display("lower = $lower, upper = $upper")
        # guard numerics: ensure lower <= upper (if not, project to midpoint)
        if lower > upper + 1e-12
            # infeasible pair due to numerical issues; pick midpoint
            display("INFEASIBILE")
            bound_mid = 0.5*(lower + upper)
            σ = clamp(σ, bound_mid, bound_mid)
        else
            σ = clamp(σ, lower, upper)
        end

        # check convergence (norm of change)
        if abs(σ - σ_prev) <= tol && abs(z - z_prev) <= tol && abs(t - t_prev) <= tol && norm(u - u_prev) <= tol
            # converged
            return σ, z, t, u
        end
    end

    # if not converged, return current iterate (warn user)
    @warn "proj_sigma_z_t_alt did not fully converge within maxiter; returning last iterate."
    return σ, z, t, u
end



# parametri di esempio
T = 6 * 3.1e3
ρ1 = 0.3*T
ρ2 = 0.8*T
z0 = log(1905.0)
μ1 = ρ1*exp(-z0)
μ2 = ρ2*exp(-z0)
zmin = z0 - 5.0
zmax = z0 + 1.0

# candidato e u
hatσ = 100.0
hatz = z0 + 0.1
hatt = 0.005
u = [50.0, 10.0, 0.0]


σp, zp, tp, up = proj_sigma_z_t_alt(hatσ, hatz, hatt, u, μ1, μ2, z0, zmin, zmax, 200, 1e-9)

println("σ_proj = ", σp)
println("z_proj = ", zp)
println("t_proj = ", tp)
println("u_norm_proj = ", norm(up))



