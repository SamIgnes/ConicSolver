using LinearAlgebra
using SparseArrays
using Plots


mutable struct INEQ
    Ind_NonNeg:: Vector{Int}  # Indici delle variabili con vincoli di non negatività
    Ind_Box:: Vector{Int}  # Indici delle variabili con vincoli box (min, max)
    rhs_BoxMin:: Vector{Float64}  # Valori t per i vincoli box Min
    rhs_BoxMax:: Vector{Float64}  # Valori t per i vincoli box Max
    Ind_InGen:: Vector{Vector{Int}}  # Indici delle variabili con vincoli generali 
    Coeff_InGen:: Vector{Vector{Float64}}  # Coefficienti per i vincoli generali
    rhs_inGen:: Vector{Float64}  # Valori t per i vincoli generali  
end

"""
    struct SOC

Represents a collection of Second-Order Cones (SOC).  

Each cone is defined by:  
- A set of indices corresponding to the variables inside the norm.  
- A single index corresponding to the `t` variable (the scalar part of the cone).  
"""

struct SOC
    Ind_Soc::Vector{Vector{Int}}  # Indices of the variables in the norm for each SOC
    Ind_t_Soc::Vector{Int}        # Indices of the corresponding t variables (one per SOC)
end


"""
    struct RSOC

Represents a collection of Rotated Second-Order Cones (RSOC).  

Each RSOC is defined by:
- `Ind_x`: indices of the vector variables x in the quadratic part.
- `Ind_u`: index of the scalar variable u (must be non-negative).
- `Ind_v`: index of the scalar variable v (must be non-negative).

The RSOC constraint is: `||x||^2 <= 2 * u * v`, with `u >= 0` and `v >= 0`.
"""
struct RSOC
    Ind_x::Vector{Vector{Int}}  # Indices of x variables for each RSOC
    Shift_x::Vector{Float64}   # Shift values for x variables (if any)
    Ind_u::Vector{Int}          # Indices of u variables
    Ind_v::Vector{Int}          # Indices of v variables
    v::Vector{Float64}          # Optional: values for v (if fixed)
end


struct SOCP
    c::Vector{Float64}  # cost vector
    A::Matrix{Float64}  # equality constraint matrix
    b::Vector{Float64}  # equality constraint rhs
    Soc :: SOC   # per SOC
    Rsoc :: RSOC # per RSOC
    Ineq :: INEQ         # Inequality constraints 
end

# --- Proiezione sul cono di Lorentz per (sigma, u) ---
# Restituisce sigma_proiettato (u è fisso)
function proj_soc_sigma_u(σ_hat, u_hat)
    nu = norm(u_hat)
    if nu <= σ_hat
        return σ_hat, u_hat
    elseif nu <= -σ_hat
        return 0.0, zeros(size(u_hat))
    else
        σ_proj = 0.5*(σ_hat + nu)
        u_proj = σ_proj * u_hat / nu
        return σ_proj, u_proj
    end
end

# --- Proiezione sull'epigrafo t >= (z-z0)^2 usando Newton su z ---
# Dati: z_hat, t_hat, z0, bounds zmin,zmax
# Restituisce (z_proj, t_proj)
function proj_epigraph_quadratic(z_hat, t_hat, z0, zmin=-Inf, zmax=Inf,
                                 tol=1e-10, maxit=200)
    s_hat = z_hat - z0
    # se già fattibile
    if t_hat >= s_hat^2 && z_hat >= zmin && z_hat <= zmax
        return z_hat, t_hat
    end

    # inizializzazione per Newton:
    # se t_hat >= 0, un buon guess è z0 + sign(s_hat)*sqrt(max(t_hat,0))
    if t_hat >= 0
        z = z0 + (s_hat == 0 ? 0.0 : sign(s_hat)*sqrt(t_hat))
    else
        z = clamp(z_hat, zmin, zmax)
    end

    for it = 1:maxit
        s = z - z0
        # funzione F(z) = ( (z-z0)^2 - t_hat )^2 + (z - z_hat)^2
        f = 4*s*(s^2 - t_hat) + 2*(z - z_hat)          # derivative
        df = 12*s^2 - 4*t_hat + 2                       # second derivative
        # safeguard
        if abs(df) < 1e-12
            # fallback small step
            dz = -f * 1e-3
        else
            dz = - f / df
        end
        # step limit for stability
        if !isfinite(dz)
            dz = sign(f)*1e-6
        elseif abs(dz) > 1.0
            dz = sign(dz)*1.0
        end
        z_new = z + dz
        # enforce z box
        z_new = clamp(z_new, zmin, zmax)
        if abs(z_new - z) < tol
            z = z_new
            break
        end
        z = z_new
    end

    t = (z - z0)^2
    return z, t
end

# --- main: alternate projections ---
"""
proj_sigma_z_t_alt(hatσ, hatz, hatt, u; μ1, μ2, z0, zmin, zmax, maxiter, tol)

Alternate projections onto:
 1) SOC: σ >= ||u||
 2) Epigraph parabola + box on z: t >= (z-z0)^2 and zmin <= z <= zmax
 3) Clamp σ with lower/upper depending on (z,t):
       lower = μ1*(1 - (z-z0) + 0.5*t)
       upper = μ2*(1 - (z-z0))

Returns (σ_proj, z_proj, t_proj).
"""   
function proj_sigma_z_t_alt(hatσ, hatz, hatt, u, μ1, μ2, z0,
                            zmin=-Inf, zmax=Inf, maxiter=200, tol=1e-9)

    # initialize
    σ = hatσ
    z = clamp(hatz, zmin, zmax)
    t = max(hatt, (z - z0)^2)   # initial feasible-ish for t
    # if hatt smaller than parabola, we set t accordingly after first epigraph projection

    for it = 1:maxiter
        σ_prev, z_prev, t_prev, u_prev = σ, z, t, u

        # 1) proj SOC on (σ,u) -> updates only σ
        σ,u = proj_soc_sigma_u(σ, u)

        # 2) proj epigraph t >= (z-z0)^2 with box on z -> updates z,t
        # we call the Newton-based routine with current z,t as starting info
        z_proj, t_proj = proj_epigraph_quadratic(z, t, z0, zmin, zmax, 1e-10, 200)
        z, t = z_proj, t_proj

        # 3) clamp σ using bounds computed from new (z,t)
        lower = μ1*(1 - (z - z0) + 0.5*t)
        upper = μ2*(1 - (z - z0))
        # guard numerics: ensure lower <= upper (if not, project to midpoint)
        if lower > upper + 1e-12
            # infeasible pair due to numerical issues; pick midpoint
            display("INFEASIBILE")
            bound_mid = 0.5*(lower + upper)
            σ = clamp(σ, bound_mid, bound_mid)
        else
            σ = clamp(σ, lower, upper)
        end

        # check convergence (norm of change)
        if abs(σ - σ_prev) <= tol && abs(z - z_prev) <= tol && abs(t - t_prev) <= tol && norm(u - u_prev) <= tol
            # converged
            return σ, z, t, u
        end
    end

    # if not converged, return current iterate (warn user)
    @warn "proj_sigma_z_t_alt did not fully converge within maxiter; returning last iterate."
    return σ, z, t, u
end

function projSOCP(v, Soc, Rsoc, Ineq)
    z = copy(v)
    Nvars = length(Soc.Ind_t_Soc)
    zmin = Ineq.rhs_BoxMin
    zmax = Ineq.rhs_BoxMax
    z0 = Rsoc.Shift_x
    T = 6 * 3.1e3
    ρ1 = 0.3*T
    ρ2 = 0.8*T
    Isp = 225
    φ = 27*(π/180)  # angolo di inclinazione del motore
    m_wet   = 1905.0
    alpha  = 1/(Isp*9.80665*cos(φ))



    for i = 1: Nvars

        zmin = log(m_wet - alpha*ρ1*((i-1)*1.0))
        zmax = z0[i]
        μ1 = ρ1*exp(-z0[i])
        μ2 = ρ2*exp(-z0[i])        
        # Proiezione su ogni cono SOC con vincoli aggiuntivi su (σ,z
        hatσ = v[Soc.Ind_t_Soc[i]]
        hatz = v[(i-1) * 12 + 7 ]  
        hatt = v[(i-1) * 12 + 12]  
        u = v[Soc.Ind_Soc[i]]

        σp, zp, tp, up = proj_sigma_z_t_alt(hatσ, hatz, hatt, u, μ1, μ2, z0[i], zmin, zmax, 200, 1e-9)

        z[Soc.Ind_t_Soc[i]] = σp
        z[(i-1) * 12 + 7] = zp
        z[(i-1) * 12 + 12] = tp
        z[Soc.Ind_Soc[i]] = up 

        # display("σ_proj = $σp, z_proj = $zp, t_proj = $tp, ||u_proj|| = $(norm(up))")

    end

    return z
end