using LinearAlgebra
using Plots
using TickTock
using BenchmarkTools
using SparseArrays

include("FunctionsProjections")


# ================================================
# ADMM SOCP con vincoli conici, Ax = g e Ax ≤ c
# ================================================
function admm_socp(x0, cones, obj, H; 
                   F=nothing, g=nothing,    # vincoli lineari di uguaglianza
                   A=nothing, c=nothing, Clamp,    # vincoli lineari di disuguaglianza
                   ρ=1.0, max_iter=200, tol=1e-6)

    n = length(x0)
    m = length(cones)
    nu = Clamp

    # Variabili primali
    x = copy(x0)
    z = m > 0 ? zeros(n, m) : zeros(0,0)
    u = m > 0 ? zeros(n, m) : zeros(0,0)


    # Variabili per disuguaglianze
    if A !== nothing && length(A)
        zA = zeros(n)
        uA = zeros(n)
    end

    if nu > 0
        zU = zeros(nu)
        uU = zeros(nu)
    end


    # ============================
    # Costruzione della matrice Hx per l'x-update
    # ============================
    Hx = copy(H)  # H è la matrice quadratica dell'obiettivo

    # 1️⃣ Contributo dei vincoli conici
    if m > 0
        for i in 1:n
            Hx[i,i] += ρ * m   # tutte le variabili coinvolte nei vincoli conici
        end
    else 
        sum_z_u = zeros(n)
    end

    # 2️⃣ Contributo dei vincoli lineari di disuguaglianza Ax <= c
    if A !== nothing && length(A) > 0
        for i in 1:n
            Hx[i,i] += ρ   # aggiungi ρ solo alle variabili coinvolte in A
        end
    end

    # 3️⃣ Contributo dei vincoli di clamp su u
    if nu > 0
        clamp_indices = (n - nu + 1):n  # indici delle variabili u
        for i in clamp_indices
            Hx[i,i] += ρ   # aggiungi ρ solo alle variabili di controllo u
        end
    end


    Hx = sparse(Hx)  # Hx quadraticausing SparseArrays

    if F === nothing && size(F,1) == 0
        Hx_fact = factorize(Hx)
    else
        KKT = [Hx F'; F spzeros(size(F,1), size(F,1))]
        KKT_fact = lu(KKT)
    end


    for k in 1:max_iter
        # =========================================
        # x-update completo per costo quadratico
        # =========================================


        # Contributo dei vincoli di disuguaglianza lineari
        extra_term = zeros(n)
       if A !== nothing && length(A) > 0
            @views extra_term .+= zA - uA
        end
        if nu > 0
            @views extra_term[n-nu+1:end] .+= zU - uU
        end


        if m > 0 
            sum_z_u = zeros(n)
            for j in 1:m
                @views sum_z_u .+= z[:,j] .- u[:,j]
            end
        end


        # Vettore right-hand side
        f = ρ*sum_z_u + ρ*extra_term - obj

        if F !== nothing && size(F,1) != 0
            # Vincoli lineari di uguaglianza F x = g
            # Risolvo sistema KKT:
            # [Hx  F'; F 0] [x; λ] = [f; g]
            rhs = vcat(f, g)
            sol = KKT_fact \ rhs
            x = sol[1:n]      # estraggo x
        else
            # Nessun vincolo lineare di uguaglianza
            x = Hx_fact \ f
        end

        # --- z-update (coni) ---
        if m>0
            for i in 1:m
                c_i, r_i = cones[i]
                z[:,i] = proj_soc!(x + u[:,i], c_i, r_i)

            end
        end

        # --- z-update (disuguaglianze Ax ≤ c) ---
        if A !== nothing && length(A)
            zA = proj_polytope!(x + uA, A, c)
        end

        # z-update per controllo con vincolo u_min <= u <= u_max

        @views xU = x[(n - nu + 1):n] # estraggo u_k da x
        if nu > 0
            zU .= clamp.(xU .+ uU, -0.2, 0.2)
        end


        # --- u-update ---
        if m>0
            for i in 1:m
                u[:,i] += x - z[:,i]
            end
        end
        if A !== nothing && length(A)
            uA += x - zA
        end

        if nu > 0
            uU += xU - zU
        end

        # --- Controllo convergenza ---
        r_norm = 0.0
        if m>0
            r_norm += sum(norm.(eachcol(x .- z)))
        end

        if A !== nothing
            r_norm += norm(x - zA)
        end

        if nu > 0
            r_norm += norm(x[n-nu+1:end] - zU)
        end

        if r_norm < tol
            println("Converged at iteration $k")
            break
        end
    end


    # ================================
    # Check generale fattibilità
    # ================================
    feasible = true


    # Vincoli conici
    for (c_, r_) in cones
        dist = norm(x - c_)
        if dist > r_ + tol
            println("⚠️ Violato vincolo conico: distanza = $dist, raggio = $r_")
            feasible = false
        end
    end

    # Vincoli lineari di uguaglianza
    if F !== nothing && size(F,1) != 0
        residual = norm(F * x - g)
        if residual > tol
            println("⚠️ Violati vincoli lineari di uguaglianza: residuo = $residual")
            feasible = false
        end
    end

    # Vincoli di disuguaglianza
    if A !== nothing
        viol = A * x - c
        if any(viol .> tol)
            println("⚠️ Violati vincoli di disuguaglianza: max violazione = $(maximum(viol))")
            feasible = false
        end
    end

    return x, z
end


# x0 = zeros(2)
# cones = [([1.0, 0.0], 2.0)]
# A = [1.0 1.0]
# c = [1.0]
# obj = [1.0, 1.0]

# x_sol, z_sol = admm_socp(x0, cones, obj; A=A, c=c, ρ=1.0, max_iter=300, tol=1e-6)
# println("Soluzione x* = ", x_sol)


# # Punto iniziale
# x0 = zeros(3)

# # Vincoli conici: sfere centrati sugli assi, raggio 2
# cones = [
#     ([2.0, 0.0, 0.0], 2.0),
#     ([0.0, 2.0, 0.0], 2.0),
#     ([0.0, 0.0, 2.0], 2.0)
# ]

# # Vincoli lineari disuguali: politopo 3D
# # Ad esempio: x1 + x2 + x3 <= 1, x1 - x2 <= 0.5, x2 + x3 <= 1.5
# A = [
#     1.0 1.0 1.0;
#     1.0 -1.0 0.0;
#     0.0 1.0 1.0
# ]
# c = [1.0, 0.5, 1.5]

# # Obiettivo lineare: minimizzare la somma con peso positivo su x1 e x2
# obj = [1.0, 2.0, 1.0]

# # Parametri ADMM
# ρ = 1.0
# max_iter = 500
# tol = 1e-6

# # Risolvi
# x_sol, z_sol = admm_socp(x0, cones, obj; A=A, c=c, ρ=ρ, max_iter=max_iter, tol=tol)

# println("\nSoluzione x* = ", x_sol)
# for i in 1:length(z_sol)
#     println("z[$i]* = ", z_sol[i], "   distanza_x_z = ", norm(x_sol - z_sol[i]))
# end

# # Controllo vincoli lineari
# println("A*x - c = ", A*x_sol - c)


# # Punto iniziale
# x0 = [0.0, 0.0, 0.0]

# # Vincoli conici: sfere più piccole in modo da forzare x* sulla superficie
# cones = [
#     ([1.0, 0.0, 0.0], 1.0),  # raggio piccolo
#     ([0.0, 1.0, 0.0], 1.0),
#     ([0.0, 0.0, 1.0], 1.0)
# ]

# # Vincoli lineari disuguali: politopo 3D
# # Alcuni vincoli saranno attivi nella soluzione
# A = [
#     1.0 1.0 1.0;   # x1+x2+x3 <= 1
#     1.0 -1.0 0.0;  # x1-x2 <= 0.5
#     0.0 1.0 1.0    # x2+x3 <= 1
# ]
# c = [1.0, 0.5, 1.0]

# # Obiettivo lineare: spingiamo x verso valori positivi
# obj = [-1.0, -1.0, -0.5]  # vogliamo massimizzare x (ADMM minimizza -obj^T x)

# # Parametri ADMM
# ρ = 1.0
# max_iter = 500
# tol = 1e-6

# # Risolvi
# x_sol, z_sol = admm_socp(x0, cones, obj; A=A, c=c, ρ=ρ, max_iter=max_iter, tol=tol)

# println("\nSoluzione x* = ", x_sol)
# for i in 1:length(z_sol)
#     println("z[$i]* = ", z_sol[i], "   distanza_x_z = ", norm(x_sol - z_sol[i]))
# end

# # Controllo vincoli lineari
# println("A*x - c = ", A*x_sol - c)


# # =========================
# # Punto iniziale
# x0 = [0.0, 0.0]

# # Vincoli lineari Ax <= c
# A = [1.0 0.0;
#      0.0 1.0;
#      -1.0 0.0;
#      0.0 -1.0]
# c = [1.0, 1.0, 1.0, 1.0]

# # Obiettivo lineare
# obj = [1.0, 1.0]

# # Nessun vincolo conico
# cones = []

# # Parametri ADMM
# ρ = 1.0
# max_iter = 200
# tol = 1e-6

# # Risolvi usando ADMM
# x_sol, z_sol = admm_socp(x0, cones, obj; A=A, c=c, ρ=ρ, max_iter=max_iter, tol=tol)

# println("Soluzione x* = ", x_sol)
# println("A*x - c = ", A*x_sol - c)


# Parametri
T = 10.0
N = 50
dt = T/N

# Numero variabili stato
nx = 2*(N+1)  # x_k, v_k
nu = N        # u_k

# Costruzione del problema lineare
# Variabili concatenano: [x_0..x_N, v_0..v_N, u_0..u_{N-1}]
n = nx + nu

# Obiettivo: J = sum(u_k^2)
obj = zeros(n)
obj[nx+1:end] .= 0.0  # minimizziamo u_k^2 → implementiamo in ADMM come obj^T x ~0, useremo proiezione dinamica

# Vincoli dinamica Ax = g
# Matrice di uguaglianza
F = zeros(2*N+4, n)

for k in 1:N
    # x_{k+1} - x_k - dt*v_k = 0
    F[k, k] = -1
    F[k, k+1] = 1
    F[k, N+1+k] = -dt  # v_k

    # v_{k+1} - v_k - dt*u_k = 0
    F[N+k, N+1+k] = -1      # v_k
    F[N+k, N+1+k+1] = 1          # v_{k+1}
    F[N+k, nx+k] = -dt         # u_k
end

# Vincoli finali
xT_idx = N+1
vT_idx = 2*(N+1)
F[2*N+1, xT_idx] = 1.0   # x_N = 5
F[2*N+2, vT_idx] = 1.0   # v_N = 0

xI_idx = 1
vI_idx = N+2
F[2*N+3, xI_idx] = 1.0   # x_N = 5
F[2*N+4, vI_idx] = 1.0   # v_N = 0

g = vcat(zeros(2*N),[5.0, 0.0, 0.0, 0.0])  # condizioni iniziali e finali
# In ADMM potremmo gestire condizioni finali come vincoli aggiuntivi
# oppure aggiungere penalità quadratica nell'obiettivo

# Punto iniziale
x0 = zeros(n)

# Nessun cono
cones = []

# ADMM
ρ = 1.0
max_iter = 500
tol = 1e-6

# # Vincoli lineari Ax <= c
A = []
c = []


H = zeros(n,n)
H[nx+1:end, nx+1:end] = dt*I(N)   # peso integrale u_k^2


@btime x_sol, z_sol = admm_socp(x0, cones, obj, H, F=F, g=g, Clamp = N, ρ=ρ, max_iter=max_iter, tol=tol)

# Soluzione analitica bang-bang (forza costante u_max per metà tempo, -u_max per seconda metà)
u = ones(N)
u[1:div(N,2)] .= 2*5/T^2  # accelerazione positiva
u[div(N,2)+1:end] .= -2*5/T^2  # decelerazione negativa

# # Profilo velocità e posizione
# v = zeros(N+1)
# x = zeros(N+1)
# for k in 1:N
#     v[k+1] = v[k] + dt*u[k]
#     x[k+1] = x[k] + dt*v[k]
# end

x_vals = x_sol[1:N+1]      # posizioni x_k
v_vals = x_sol[N+2:2*(N+1)]  # velocità v_k
u_vals = x_sol[2*(N+1)+1:end]  # forze u_k

# Plot
t = 0:dt:T

p2 = plot(t[1:end], x_vals, xlabel="Time [s]", ylabel="Position x", title="Profilo della posizione ottima", legend=false)
p3 = plot(t[1:end],v_vals, xlabel="Time [s]", ylabel="veloity v", title="Profilo della velocità ottima", legend=false)
p4 = plot(t[2:end], u_vals, xlabel="Time [s]", ylabel="Force u", title="Profilo della forza ottima", legend=false)

plot( p2, p3, p4, layout=(3,1), size=(700,1000))
