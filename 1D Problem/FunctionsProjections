# ================================================
# Proiezione su politopo { z : A z ≤ c } via duale + PGD
# ================================================
function proj_polytope(v::Vector, A::Matrix, c::Vector; 
                       max_iter=500, tol=1e-8)

    m, n = size(A)
    λ = zeros(m)   # moltiplicatori duali
    Av = A * v

    # stima passo ottimale: 1 / L con L = ||A*A'||₂
    L = opnorm(A * A', 2)
    α = 1.0 / L

    for k in 1:max_iter
        # gradiente del duale: ∇f(λ) = A*A' λ - (Av - c)
        grad = (A * (A' * λ)) - (Av - c)

        # step di discesa con proiezione
        λ_new = λ - α * grad
        λ_new = max.(λ_new, 0.0)

        # controllo convergenza
        if norm(λ_new - λ) < tol
            λ = λ_new
            break
        end
        λ = λ_new
    end

    # ricostruzione soluzione primale
    z = v - A' * λ
    return z
end

function proj_rsoc(v::Vector)
    n = length(v)
    z = copy(v)
    t = norm(v[3:end])

    # Caso già nel cono
    if v[1] >= 0 && v[2] >= 0 && v[1]*v[2] >= t^2
        return v
    end

    # Caso origine / componenti negative
    if t == 0
        z[1] = max(v[1], 0)
        z[2] = max(v[2], 0)
        z[3:end] .= 0
        return z
    end

    # Caso generale
    s = (v[1] + v[2])
    if t^2 <= (s^2)/4 && s > 0
        alpha = (s + 2*t)/2
        z[1] = alpha
        z[2] = alpha
        z[3:end] .= alpha / t * v[3:end]
    else
        # t^2 > (v1+v2)^2/4
        z[1] = t
        z[2] = t
        # z[3:n] rimane invariato
    end
    return z
end

function proj_soc(u::AbstractVector, t::Real)
    nx = norm(u)
    if nx <= t
        return copy(u), t
    elseif nx <= -t
        return zeros(eltype(u), length(u)), 0.0
    else
        # caso generico
        alpha = (nx + t) / (2nx)
        return alpha * u, (nx + t) / 2
    end
end
